#!/usr/bin/env python3

# Copyright (c) 2014,2018 ADLINK Technology Inc.
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
# which is available at https://www.apache.org/licenses/LICENSE-2.0.
#
# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
#
# Contributors: Gabriele Baldoni, ADLINK Technology Inc. - Base plugins set


#
# This plugin use Full LinuxBridge implementation for
# connection points and virtual links
#

import sys
import os
import uuid
import struct
import json
import socket
import signal
import base64
import binascii
import hashlib
import psutil
import netifaces
from jinja2 import Environment
from fog05.interfaces.NetworkPlugin import *
from fog05 import Yaks_Connector
from mvar import MVar
from fog05.DLogger import DLogger

VNI_LIMIT = 16777215
VLAN_LIMIT = 4095

class LinuxBridge(NetworkPlugin):

    def __init__(self, name, version, plugin_uuid, manifest):

        super(LinuxBridge, self).__init__(version, plugin_uuid)
        self.name = name
        loc = manifest.get('configuration').get('ylocator').split('/')[1]
        self.connector = Yaks_Connector(loc)
        self.logger = DLogger(debug_flag=True)
        self.node = manifest.get('configuration').get('nodeid')
        self.manifest = manifest
        self.configuration = manifest.get('configuration', {})
        self.pid = os.getpid()
        self.var = MVar()
        self.agent_conf = self.connector.loc.actual.get_node_configuration(self.node)
        self.use_vlan = self.configuration.get('use_vlan', False)
        self.vlan_face = self.configuration.get('vlan_interface', None)
        self.vlan_range = self.configuration.get('vlan_range', [0, VLAN_LIMIT])

        self.wait_dependencies()
        self.logger.info('__init__()', ' Hello from Linux Bridge Plugin')



        self.BASE_DIR = os.path.join(
            self.agent_conf.get('agent').get('path'), 'linuxbridge')

        self.DHCP_DIR = 'dhcp'
        self.HOME = 'network/{}'.format(self.uuid)
        file_dir = os.path.dirname(__file__)
        self.DIR = os.path.abspath(file_dir)
        self.overlay_interface = manifest.get('configuration').get('dataplane_interface')
        if self.overlay_interface is None:
            self.agent_conf.get('agent').get('mgmt_interface')

        if self.vlan_face is None:
            self.vlan_face = self.overlay_interface

        self.networks = {}
        self.net_files = {}
        self.intfs = {}
        self.ports = {}
        self.bridges = {}
        self.routers = {}

        signal.signal(signal.SIGINT, self.__catch_signal)
        signal.signal(signal.SIGTERM, self.__catch_signal)

    def __catch_signal(self, signal, _):
        if signal in [2, 15]:
            self.var.put(signal)

    def start_network_manager(self):
        self.logger.info(
            'start_runtime()', 'Linux Bridge Plugin - Starting...')

        if self.call_os_plugin_function('dir_exists', {'dir_path': self.BASE_DIR}):
            if not self.call_os_plugin_function('dir_exists', {'dir_path': os.path.join(self.BASE_DIR, self.DHCP_DIR)}):
                self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.DHCP_DIR)})
        else:
            self.call_os_plugin_function(
                'create_dir', {'dir_path': os.path.join(self.BASE_DIR)})
            self.call_os_plugin_function(
                'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.DHCP_DIR)})

        # if self.configuration.get('data_subnet'):
        #     cird = self.configuration.get('data_subnet')

        #     data = self.connector.loc.actual.get_node_info(self.node)
        #     for n in data.get('network'):
        #         intf_cird = self.__ip_mask_to_cird(
        #             n.get('inft_configuration').get('ipv4_address'),
        #             n.get('inft_configuration').get('ipv4_netmask')
        #         )
        #         if cird == intf_cird:
        #             self.overlay_interface = n.get('intf_name')

        if self.overlay_interface is None:
            self.agent_conf.get('agent').get('mgmt_interface')

        if self.overlay_interface is None or self.overlay_interface == 'None':
            self.logger.error('start_network_manager()','Data plane interface cannot be None!')
            exit(-1)

        d = {
            'create_virtual_interface': self.create_virtual_interface,
            'delete_virtual_interface': self.delete_virtual_interface,
            'create_virtual_bridge': self.create_virtual_bridge,
            'delete_virtual_bridge': self.delete_virtual_bridge,
            'create_bridges_if_not_exist': self.create_bridges_if_not_exist,
            'connect_interface_to_connection_point': self.connect_interface_to_connection_point,
            'disconnect_interface': self.disconnect_interface,
            'connect_cp_to_vnetwork': self.connect_cp_to_vnetwork,
            'disconnect_cp': self.disconnect_cp,
            'delete_port': self.delete_port,
            'get_address': self.get_address,
            'create_floating_ip': self.create_floating_ip,
            'delete_floating_ip': self.delete_floating_ip,
            'assign_floating_ip': self.assign_floating_ip,
            'remove_floating_ip': self.remove_floating_ip,
            # utility functions
            'get_overlay_interface': self.get_overlay_face,
            'get_vlan_interface': self.get_vlan_face
        }

        for k in d:
            f = d.get(k)
            self.logger.info(
                '__init__()', 'Linux Bridge Plugin - Registering {}'.format(k))
            self.connector.loc.actual.add_nw_eval(self.node, self.uuid, k, f)

        self.connector.loc.desired.observe_node_networks(
            self.node, self.uuid, self.__net_observer)
        self.connector.loc.desired.observe_node_ports(
            self.node, self.uuid, self.__port_observer)
        self.connector.loc.desired.observe_node_routers(
            self.node, self.uuid, self.__router_observer)
        self.manifest.update({'pid': self.pid})
        self.manifest.update({'status': 'running'})
        self.connector.loc.actual.add_node_plugin(
            self.node, self.uuid, self.manifest)

        self.logger.info('start_runtime()', 'Linux Bridge Plugin - Data Plane (VxLAN) Interface {}'.format(self.overlay_interface))
        if self.use_vlan:
            self.logger.info('start_runtime()', 'Linux Bridge Plugin - VLAN Interface {}'.format(self.vlan_face))
            self.logger.info('start_runtime()', 'Linux Bridge Plugin - VLAN Range {}'.format(self.vlan_range))
        self.logger.info('start_runtime()', 'Linux Bridge Plugin - Started...')

        r = self.var.get()
        self.stop_network_manager()
        self.connector.close()
        exit(0)

    def stop_network_manager(self):
        for k in list(self.intfs.keys()):
            self.delete_virtual_interface(k)
        for k in list(self.ports.keys()):
            self.delete_port(k)
        for k in list(self.networks.keys()):
            self.delete_virtual_network(k)
        for k in list(self.bridges.keys()):
            self.delete_virtual_bridge(k)


    def get_overlay_face(self):
        return {'result': self.overlay_interface}

    def get_vlan_face(self):
        return {'result': self.vlan_face}

    def get_address(self, mac_address):
        self.logger.info('get_address()', 'Linux Bridge Plugin - Getting IP address for  {}'.format(mac_address))

        # LEASE FILE FORMAT
        # 1560518377 00:16:3e:5e:a8:fa 192.168.123.13 holy-gar 01:00:16:3e:5e:a8:fa

        for netid in self.networks:
            net = self.networks[netid]
            if net.get('ip_configuration') is not None:
                n_small_id = netid.split('-')[0]
                path = os.path.join(self.BASE_DIR, self.DHCP_DIR)
                lease_file = os.path.join(path,'net_{}_leases'.format(n_small_id))

                if self.call_os_plugin_function('read_file',{'file_path':lease_file}):
                    res = self.call_os_plugin_function('read_file',{'file_path':lease_file, 'root':False}).split('\n')
                    for l in res:
                        tok = l.split(' ')
                        if tok[1] == mac_address:
                            self.logger.info('get_address()', 'Linux Bridge Plugin - IP address for {} is '.format(mac_address, tok[2]))
                            return {'result': tok[2]}

        self.logger.info('get_address()', 'Linux Bridge Plugin - Unable to get IP address for {} '.format(mac_address))
        return {'result': ''}


    # todo: last item is empty-> delete
    def get_bridge_names_from_output_string(self, output):
        rows = output.split('\n')
        table = [row.split('\t') for row in rows]
        bridges_names = [item[0] for item in table]
        return bridges_names[1:]  # pop name of the table

    def get_virtual_bridges_in_node(self):
        cmd = 'sudo brctl show'
        output = self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        return self.get_bridge_names_from_output_string(output)

    # this is an eval
    def create_bridges_if_not_exist(self, expected_bridges):
        expected_bridges = json.loads(expected_bridges)
        current_bridges = self.get_virtual_bridges_in_node()
        for bridge in expected_bridges:
            if bridge not in current_bridges:
                self.create_virtual_bridge(bridge, '{}'.format(uuid.uuid4()))
        return {'result':expected_bridges}


    def check_if_interface_exists(self, iface):
        faces = psutil.net_if_addrs()
        if faces.get(iface, None) is None:
            return False
        return True

    def create_vlan_interface(self, iface, vlanid):
        cmd = 'sudo ip link add link {} name {}.{} type vlan id {}'.format(iface, iface, vlanid, vlanid)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':True})

    # this is an eval
    def create_virtual_interface(self,intf_id, descriptor):
        self.logger.info('create_virtual_interface','Creating {}'.format(intf_id))
        descriptor = json.loads(descriptor)
        intf_name = intf_id
        internal_name = '{}-i'.format(intf_id)
        external_name = '{}-e'.format(intf_id)
        start_file = self.__generate_interface_create_script(internal_name, external_name, intf_name)
        stop_file = self.__generate_interface_destroy_script(external_name, intf_name)
        cmd_start = os.path.join(self.BASE_DIR, start_file)
        cmd_stop = os.path.join(self.BASE_DIR, stop_file)
        self.call_os_plugin_function('execute_command',{'command':cmd_start,'blocking':True, 'external':True})
        descriptor.update({'intf_id':intf_id})
        self.logger.info('create_virtual_interface','Created {}'.format(intf_id))


        intf_info = {
            'descriptor':descriptor,
            'int_name': internal_name,
            'ext_name':external_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        self.intfs.update({intf_id: intf_info})
        if descriptor.get('cp_id') is not None:
            cpid = descriptor.get('cp_id')
            self.logger.info('create_virtual_interface','Attach to {}'.format(cpid))
            self.connect_interface_to_connection_point(intf_id, cpid)
            self.logger.info('create_virtual_interface','Attached to {}'.format(cpid))
        return {'result':intf_info}

    # this is an eval
    def delete_virtual_interface(self, intf_id):
        self.logger.info('delete_virtual_interface','{} has to be deleted'.format(intf_id))
        intf_info = self.intfs.get(intf_id)
        if intf_info is None:
            self.logger.error('delete_virtual_interface','{} does not exist'.format(intf_id))
            return {'error':12}
        stop_file = intf_info.get('stop')
        if intf_info.get('descriptor').get('cp_id') is not None:
            cpid = intf_info.get('descriptor').get('cp_id')
            self.disconnect_interface(intf_id)
        self.call_os_plugin_function('execute_command',{'command':stop_file,'blocking':True, 'external':True})
        self.call_os_plugin_function('remove_file',{'file_path':stop_file})
        self.call_os_plugin_function('remove_file',{'file_path':intf_info.get('start')})
        self.intfs.pop(intf_id)
        self.logger.info('delete_virtual_interface','{} removed'.format(intf_id))
        return {'result':intf_id}

    # this is an eval
    def create_virtual_bridge(self, name, uuid):
        cmd = 'sudo ip link add {} type bridge'.format(name)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        br_uuid = uuid
        self.bridges.update({br_uuid: name})
        return {'result':{'uuid':br_uuid, 'name':name}}


    # this is an eval
    def delete_virtual_bridge(self, br_uuid):
        self.logger.info('delete_virtual_bridge', 'Removing {}'.format(br_uuid))
        name = self.bridges.get(br_uuid)
        if name is None:
            self.logger.error('delete_virtual_bridge', 'Bridge {} not existing'.format(br_uuid))
            return {'error':-2}
        cmd = 'sudo ip link del {}'.format(name)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        self.bridges.pop(br_uuid)
        self.logger.info('delete_virtual_bridge', 'Removed {}'.format(br_uuid))
        return {'result':br_uuid}

    def create_port(self, record):
        cp_id = record.get('uuid')
        descriptor = self.get_port_descriptor(record.get('cp_uuid'))
        cp_small_id = ''.join([x[0] for x in cp_id.split('-')])
        cp_name = 'br-cp-{}'.format(cp_small_id)
        int_name = 'cp-{}-i'.format(cp_small_id)
        ext_name = 'cp-{}-e'.format(cp_small_id)
        self.logger.info('create_port', 'Creating {} {} {}'.format(cp_name, int_name, ext_name))
        start_file = self.__generate_port_create_script(int_name, ext_name, cp_name)
        stop_file = self.__generate_port_destroy_script(ext_name, cp_name)
        cmd_start = os.path.join(self.BASE_DIR, start_file)
        cmd_stop = os.path.join(self.BASE_DIR, stop_file)
        self.call_os_plugin_function('execute_command',{'command':cmd_start,'blocking':True, 'external':True})
        cp_info = {
            'descriptor':record,
            'int_name': int_name,
            'ext_name':ext_name,
            'cp_name':cp_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        self.ports.update({cp_id: cp_info})
        if descriptor.get("pair_id") is not None:
            pair_id = descriptor.get("pair_id")
            self.connect_cp_to_vnetwork(cp_id, pair_id)
        properties = {
            'int_name': int_name,
            'ext_name':ext_name,
            'cp_name':cp_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        record.update({'status':'CREATE'})
        record.update({'properties':properties})
        self.connector.loc.actual.add_node_port(self.node, self.uuid, cp_id,record)


    def delete_port(self, cp_id):
        port_info = self.ports.get(cp_id)
        if port_info is None:
            self.logger.error('delete_port','{} does not exist'.format(cp_id))
            return False
        stop_file = port_info.get('stop')
        if port_info.get('descriptor').get('pair_id') is not None:
            pair_id = port_info.get('descriptor').get('pair_id')
            self.disconnect_cp(cp_id)
        self.call_os_plugin_function('execute_command',{'command':stop_file,'blocking':True, 'external':True})
        self.call_os_plugin_function('remove_file',{'file_path':stop_file})
        self.call_os_plugin_function('remove_file',{'file_path':port_info.get('start')})
        self.ports.pop(cp_id)
        self.connector.loc.actual.remove_node_port(self.node, self.uuid, cp_id)


    def create_router(self, record):
        router_id = record.get('uuid')
        self.logger.info('create_router()', 'Creating {} Record: {}'.format(router_id, record))
        # {
        #   'uuid':'12345678-1234-1234-1234-123456789012',
        #   'state':'CREATE',
        #   'router_ns': 'r-12345678-ns',
        #   'nodeid': ''12345678-1234-1234-1234-123456789012',
        #   'ports': [
        #       {
        #          'port_type':'EXTERNAL',
        #          'ext_face':'ens2',
        #          'ip_address':'',
        #          'faces':['r-12345678-e0']
        #       },
        #       {
        #          'port_type':'INTERNAL',
        #          'faces': [ 'r-12345678-e1-i', 'r-12345678-e1-e'],
        #          'ip_address': '192.168.123.1/24',
        #          'pair_id': '12345678-1234-1234-1234-123456789012'
        #       }
        #   ]
        # }

        self.logger.info('create_router()', 'Creating Router NS: {}'.format(record['router_ns']))
        cmd_new_ns = 'sudo ip netns add {}'.format(record['router_ns'])
        cmd_ns_forwarding = 'sudo ip netns exec {} sysctl -w net.ipv4.ip_forward=1'.format(record['router_ns'])
        self.call_os_plugin_function('execute_command', {'command':cmd_new_ns, 'blocking':True, 'external':True})
        self.call_os_plugin_function('execute_command', {'command':cmd_ns_forwarding, 'blocking':True, 'external':True})
        ext_face = ''
        for p in record['ports']:

            if p['port_type'] == 'EXTERNAL':
                cmd_add_macvlan = 'sudo ip link add {} link {} type macvlan mode vepa'.format(p['faces'][0], p['ext_face'])
                cmd_port_to_ns = 'sudo ip link set {} netns {}'.format(p['faces'][0], record['router_ns'])
                cmd_port_up = 'sudo ip netns exec {} ip link set {} up'.format(record['router_ns'], p['faces'][0])

                self.logger.info('create_router()', 'Creating EXTERNAL PORT: {} and assiging to router NS {}'.format(p['faces'][0], record['router_ns']))
                self.call_os_plugin_function('execute_command', {'command':cmd_add_macvlan, 'blocking':True, 'external':True})
                self.call_os_plugin_function('execute_command', {'command':cmd_port_to_ns, 'blocking':True, 'external':True})
                self.call_os_plugin_function('execute_command', {'command':cmd_port_up, 'blocking':True, 'external':True})
                if p['ip_address'] == '':

                    self.logger.info('create_router()', 'Asking address for face: {}'.format(p['faces'][0]))

                    cmd_dhcp_client = 'sudo ip netns exec {} dhclient {}'.format(record['router_ns'], p['faces'][0])
                    self.call_os_plugin_function('execute_command', {'command':cmd_dhcp_client, 'blocking':True, 'external':True})

                    cmd_get_address = 'sudo ip netns exec {} fos_get_address {}'.format(record['router_ns'], p['faces'][0])

                    addr = self.call_os_plugin_function('execute_command', {'command':cmd_get_address, 'blocking':True, 'external':False})
                    self.logger.info('create_router()', 'Returing: {}'.format(addr))
                    addr = addr[0]['result']

                    p.update({'ip_address':addr})
                else:
                    self.logger.info('create_router()', 'Assing {} address for face: {}'.format(p['ip_address'], p['faces'][0]))
                    cmd_add_addr = 'sudo ip netns exec {} ip addr add {} dev {}'.format(record['router_ns'], p['ip_address'], p['faces'][0])
                    self.call_os_plugin_function('execute_command', {'command':cmd_add_addr, 'blocking':True, 'external':True})
                self.logger.info('create_router()', 'Router EXTERNAL PORT Created: {}'.format(p['faces'][0]))
                ext_face = p['faces'][0]

            elif p['port_type'] == 'INTERNAL':
                self.logger.info('create_router()', 'Creating INTERNAL PORT: {}<->{}'.format(p['faces'][0], p['faces'][1]))

                cmd_veth_pair = 'sudo ip link add {} type veth peer name {}'.format(p['faces'][0], p['faces'][1])
                cmd_i_face_to_ns = 'sudo ip link set {} netns {}'.format(p['faces'][0], record['router_ns'])
                cmd_i_face_up = 'sudo ip netns exec {} ip link set {} up'.format(record['router_ns'], p['faces'][0])

                self.call_os_plugin_function('execute_command', {'command':cmd_veth_pair, 'blocking':True, 'external':True})
                self.call_os_plugin_function('execute_command', {'command':cmd_i_face_to_ns, 'blocking':True, 'external':True})
                self.call_os_plugin_function('execute_command', {'command':cmd_i_face_up, 'blocking':True, 'external':True})

                net_record = self.networks.get(p['pair_id'])
                net_ns = net_record['properties']['net_ns']
                net_dev = net_record['properties']['virtual_device'] + '-ns'

                cmd_e_face_to_ns = 'sudo ip link set {} netns {}'.format(p['faces'][1], net_ns)
                cmd_e_face_up = 'sudo ip netns exec {} ip link set {} up'.format(net_ns, p['faces'][1])
                cmd_e_face_master = 'sudo ip netns exec {} ip link set {} master {}'.format(net_ns, p['faces'][1], net_dev)

                self.call_os_plugin_function('execute_command', {'command':cmd_e_face_to_ns, 'blocking':True, 'external':True})
                self.call_os_plugin_function('execute_command', {'command':cmd_e_face_up, 'blocking':True, 'external':True})
                self.call_os_plugin_function('execute_command', {'command':cmd_e_face_master, 'blocking':True, 'external':True})

                if p['ip_address'] == '':

                    self.logger.info('create_router()', 'Asking address for face: {}'.format(p['faces'][0]))
                    cmd_dhcp_client = 'sudo ip netns exec {} dhclient {}'.format(record['router_ns'],p['faces'][0])
                    self.call_os_plugin_function('execute_command', {'command':cmd_dhcp_client, 'blocking':True, 'external':True})

                    cmd_get_address = 'sudo ip netns exec {} fos_get_address {}'.format(record['router_ns'], p['faces'][0])

                    addr = self.call_os_plugin_function('execute_command', {'command':cmd_get_address, 'blocking':True, 'external':False})['record']

                    p.update({'ip_address':addr})
                else:
                    self.logger.info('create_router()', 'Assing {} address for face: {}'.format(p['ip_address'], p['faces'][0]))
                    cmd_add_addr = 'sudo ip netns exec {} ip addr add {} dev {}'.format(record['router_ns'], p['ip_address'], p['faces'][0])
                    self.call_os_plugin_function('execute_command', {'command':cmd_add_addr, 'blocking':True, 'external':True})

                self.logger.info('create_router()', 'Setting iptables rules...')

                cmd_iptables_nat = 'sudo ip netns exec {} iptables -t nat -A POSTROUTING -s {} -o {} -j MASQUERADE'.format(record['router_ns'], p['ip_address'], ext_face)
                cmd_iptables_forward_in = 'sudo ip netns exec {} iptables -A FORWARD -i {} -o {} -j ACCEPT'.format(record['router_ns'], ext_face, p['faces'][0])
                cmd_iptables_forward_out = 'sudo ip netns exec {} iptables -A FORWARD -o {} -i {} -j ACCEPT'.format(record['router_ns'], ext_face, p['faces'][0])

                self.call_os_plugin_function('execute_command', {'command':cmd_iptables_nat, 'blocking':True, 'external':True})
                self.call_os_plugin_function('execute_command', {'command':cmd_iptables_forward_in, 'blocking':True, 'external':True})
                self.call_os_plugin_function('execute_command', {'command':cmd_iptables_forward_out, 'blocking':True, 'external':True})


            else:
                self.logger.error('create_router()', 'Router port_type is not recognized: {}'.format(p['port_type']))

        self.logger.info('create_router()', 'Router {} created!'.format(router_id))
        self.routers.update({router_id: record})
        self.connector.loc.actual.add_node_router(self.node, self.uuid, router_id, record)


    def delete_router(self, router_id):
        router_info = self.routers.get(router_id)
        if router_info is None:
            self.logger.error('delete_router()','Router {} does not exist'.format(router_id))
            return False
        self.logger.info('delete_router()', 'Removing Router {}'.format(router_id))
        for p in router_info['faces']:
            if p['port_type'] == 'EXTERNAL':
                self.logger.info('delete_router()', 'Removing External Face {}'.format(p['faces'][0]))
                cmd_remove_face = 'sudo ip netns exec {} ip link del {}'.format(router_info['router_ns'], p['faces'][0])

                self.call_os_plugin_function('execute_command', {'command':cmd_remove_face, 'blocking':True, 'external':True})

                self.logger.info('delete_router()', 'Removed External Face {}'.format(p['faces'][0]))

            elif p['port'] == 'INTERNAL':
                self.logger.info('delete_router()', 'Removing Internal Face {}'.format(p['faces'][0]))

                net_record = self.networks.get(p['pair_id'])
                net_ns = net_record['properties']['net_ns']

                cmd_remove_face = 'sudo ip netns exec {} ip link del {}'.format(net_ns, p['faces'][1])

                self.call_os_plugin_function('execute_command', {'command':cmd_remove_face, 'blocking':True, 'external':True})

                self.logger.info('delete_router()', 'Removed Internal Face {}'.format(p['faces'][0]))
            else:
                self.logger.error('create_router()', 'Router port_type is not recognized: {}'.format(p['port_type']))



        cmd_ns_rem = 'sudo ip netns del {}'.format(router_info['router_ns'])
        self.call_os_plugin_function('execute_command', {'command':cmd_ns_rem, 'blocking':True, 'external':True})


        self.logger.info('delete_router()', 'Router {} deleted'.format(router_id))
        self.routers.pop(router_id)
        self.connector.loc.actual.remove_node_router(self.node, self.uuid, router_id)


    # network_name, net_uuid, ip_range=None, has_dhcp=False, gateway=None,
    def create_virtual_network(self, manifest):
        net_uuid = manifest.get('uuid')
        descriptor = self.get_network_descriptor(net_uuid)
        self.logger.info('create_virtual_network()','Creating Network with UUID: {}'.format(net_uuid))
        self.logger.info('create_virtual_network()','Creating Network: {}'.format(manifest))
        net = self.networks.get(net_uuid, None)
        if net is not None:
            self.logger.error(
                'create_virtual_network()', '{} network already exists'.format(net_uuid))
            return None

        n_small_id = net_uuid.split('-')[0]
        vdev_name = 'br-{}'.format(n_small_id)
        netns_name = 'fosns-{}'.format(n_small_id)

        properties = {}
        face = self.overlay_interface
        if 'face' in manifest:
            face = manifest['face']

        vni = self.__get_vni(net_uuid)
        if 'vni' in manifest:
            vni = manifest['vni']

        mcast_addr = self.__get_mcast_addr(net_uuid)
        if 'mcast_addr' in manifest:
            mcast_addr = manifest['mcast_addr']

        vlan_id = self.__get_vlan_id(net_uuid, self.vlan_range[0], self.vlan_range[1])
        if 'vlan_id' in manifest:
            vlan_id = manifest['vlan_id']

        overlay = not self.use_vlan
        if 'overlay' in manifest:
            overlay = manifest['overlay']

        if overlay:
            start_file  = self.__generate_vnet_start_script2(n_small_id, net_uuid, vni, mcast_addr, face)
            shutdown_file = self.__generate_vnet_stop_script2(n_small_id)
            self.call_os_plugin_function('execute_command',{'command':os.path.join(self.BASE_DIR, start_file),'blocking':True, 'external':True})
            properties.update({'vxlan_id': vni})
            properties.update({'mcast_addr': mcast_addr})
        else:
            properties.update({'vlan_id': vlan_id})
            start_file = self.__generate_vnet_vlan_start_script2(n_small_id, net_uuid, vlan_id, face)
            shutdown_file = self.__generate_vnet_vlan_stop_script2(n_small_id)
            self.call_os_plugin_function('execute_command',{'command':os.path.join(self.BASE_DIR, start_file),'blocking':True, 'external':True})
            properties.update({'vlan_id': vlan_id})


        # if self.use_vlan:
        #     properties.update({'vlan_id': self.__get_vlan_id(net_uuid, self.vlan_range[0], self.vlan_range[1])})
        #     vlan_id = self.__get_vlan_id(net_uuid, self.vlan_range[0], self.vlan_range[1])
        #     start_file = self.__generate_vnet_vlan_start_script(n_small_id, net_uuid)
        #     shutdown_file = self.__generate_vnet_vlan_stop_script(n_small_id)
        #     self.call_os_plugin_function('execute_command',{'command':os.path.join(self.BASE_DIR, start_file),'blocking':True, 'external':True})
        #     properties.update({'vlan_id': vlan_id})
        # else:
        #     vxlan_id = self.__get_vni(net_uuid)
        #     mcast_addr = self.__get_mcast_addr(net_uuid)
        #     start_file  = self.__generate_vnet_start_script(n_small_id, net_uuid)
        #     shutdown_file = self.__generate_vnet_stop_script(n_small_id)
        #     self.call_os_plugin_function('execute_command',{'command':os.path.join(self.BASE_DIR, start_file),'blocking':True, 'external':True})
        #     properties.update({'vxlan_id': vxlan_id})
        #     properties.update({'mcast_addr': mcast_addr})

        properties.update({'virtual_device': vdev_name})
        properties.update({'net_ns': netns_name})
        properties.update({'manager':self.uuid})

        if manifest.get('ip_configuration') is not None:
            self.logger.info('create_virtual_network()','Networks as address informations: {}'.format(manifest.get('ip_configuration')))
            dhcp_file = self.__generate_dnsmaq_script(manifest)
            self.call_os_plugin_function('execute_command',{'command':os.path.join(self.BASE_DIR, self.DHCP_DIR, dhcp_file),'blocking':True, 'external':True})

        manifest.update({'status':'CREATE'})
        manifest.update({'properties':properties})
        self.networks.update({net_uuid: manifest})
        self.net_files.update({net_uuid: (start_file, shutdown_file)})
        self.connector.loc.actual.add_node_network(self.node, self.uuid, net_uuid, manifest)
        self.logger.info('create_virtual_network()','Created {} Network'.format(net_uuid))



    def allocate_bandwidth(self, intf_uuid, bandwidth):
        raise NotImplementedError

    def assign_interface_to_network(self, network_uuid, intf_uuid):
        # brctl addif virbr0 vnet0
        # intf = self.interfaces_map.get(intf_uuid, None)
        # if intf is None:
        #     raise InterfaceNotExistingException(
        #         '{} interface not exists'.format(intf_uuid))
        # net = self.networks.get(network_uuid, None)
        # if net is None:
        #     raise BridgeAssociatedToNetworkException(
        #         '{} network not exists'.format(network_uuid))

        # br_cmd = 'sudo brctl addif {}-net {}'.format(
        #     net.get('network_name'), intf)
        # self.agent.get_os_plugin().execute_command(br_cmd)

        # return True
        pass

    # eval
    def connect_interface_to_connection_point(self, intf_id, cp_id):
        self.logger.info('connect_interface_to_connection_point()','vIntf {} <-> CP {} Network'.format(intf_id, cp_id))
        intf_info = self.intfs.get(intf_id)
        cp_info = self.ports.get(cp_id)
        self.logger.info('connect_interface_to_connection_point()','Face \n{} CP {}'.format(intf_info, cp_info))
        if intf_info is None or cp_info is None:
            self.logger.error('connect_interface_to_connection_point',
            'Nor connection point or virtual interface exist')
            return {'error':-2}
        ext_intf = intf_info.get('ext_name')
        int_cp = cp_info.get('cp_name')
        cmd = 'sudo ip link set dev {} master {}'.format(ext_intf, int_cp)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        return {'result':{'int':intf_id, 'ext':cp_id}}


    # eval
    def disconnect_interface(self, intf_id):
        intf_info = self.intfs.get(intf_id)
        if intf_info is None:
            self.logger.error('disconnect_interface',
            'Virtual interface does not exist')
            return {'error':-2}
        ext_intf = intf_info.get('ext_name')
        cmd = 'sudo ip link set dev {} nomaster'.format(ext_intf)
        return {'result':{'int':intf_id, 'ext':None}}

    # eval
    def connect_cp_to_vnetwork(self, cp_id, vnet_id):
        self.logger.info('connect_cp_to_vnetwork()','CP {} <-> {} Network'.format(cp_id, vnet_id))
        net_info = self.networks.get(vnet_id)
        cp_info = self.ports.get(cp_id)
        if net_info is None or cp_info is None:
            self.logger.error('connect_cp_to_vnetwork',
            'Nor connection point or virtual network exist')
            return {'error':-2}
        self.logger.info('connect_cp_to_vnetwork()','Net Info {}'.format(net_info))
        net_dev = net_info.get('properties').get('virtual_device')
        ext_cp = cp_info.get('ext_name')
        cmd = 'sudo ip link set dev {} master {}'.format(ext_cp, net_dev)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        self.logger.info('connect_cp_to_vnetwork()','CP {} <-> vNet {} OK'.format(cp_id, vnet_id))
        return {'result':{'int':cp_id, 'ext':vnet_id}}

    # eval
    def disconnect_cp(self, cp_id):
        self.logger.info('disconnect_cp()','Disconnecting CP {}'.format(cp_id))
        cp_info = self.ports.get(cp_id)
        if cp_info is None:
            self.logger.error('disconnect_interface',
            'Connection point does not exist')
            return {'error':-2}
        self.logger.info('disconnect_cp()','CP info {}'.format(cp_info))
        ext_cp = cp_info.get('ext_name')
        cmd = 'sudo ip link set dev {} nomaster'.format(ext_cp)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        self.logger.info('disconnect_cp()','Disconnected CP {}'.format(cp_id))
        return {'result':{'int':cp_id, 'ext':None}}



    def remove_interface_from_network(self, network_uuid, intf_uuid):
        # net = self.networks.get(network_uuid, None)
        # if net is None:
        #     raise BridgeAssociatedToNetworkException(
        #         '{} network not exists'.format(network_uuid))
        # intf = self.brmap.get(intf_uuid, None)
        # if intf is None:
        #     raise InterfaceNotExistingException(
        #         '{} interface not exists'.format(intf_uuid))
        # if intf not in net.get('intf'):
        #     raise InterfaceNotInNetworkException(
        #         '{} interface not in this networks'.format(intf_uuid))

        # net.get('intf').remove(intf)
        # return True
        pass

    def delete_virtual_network(self, network_uuid):
        self.logger.info('delete_virtual_network()','Deletting {}'.format(network_uuid))
        net = self.networks.get(network_uuid, None)
        if net is None:
            raise BridgeAssociatedToNetworkException(
                '{} network not exists'.format(network_uuid))
        # if len(net.get('interfaces')) > 0:
        #     raise NetworkHasPendingInterfacesException(
        #         '{} has pending interfaces'.format(network_uuid))



        # dnsmasq_file = os.path.join(
        #     self.BASE_DIR, self.DHCP_DIR, 'br-{}_dnsmasq.sh'.format(network_uuid.split('-')[0]))

        if net.get('ip_configuration') is not None:
            n_small_id = network_uuid.split('-')[0]
            path = os.path.join(self.BASE_DIR, self.DHCP_DIR)
            pid_file =  os.path.join(path,'net_{}.pid'.format(n_small_id))
            conf = os.path.join(path,'net_{}.conf'.format(n_small_id))
            lease_file = os.path.join(path,'net_{}_leases'.format(n_small_id))
            start_file = os.path.join(path,'dhcp_{}.sh'.format(n_small_id))
            pid = int(self.call_os_plugin_function('read_file',{'file_path':pid_file, 'root':False}))

            dhcp_intf = 'dhcp-{}-e'.format(n_small_id)
            killcmd = 'sudo kill -9 {}'.format(pid)
            self.call_os_plugin_function('execute_command',{'command':killcmd,'blocking':True, 'external':True})
            # self.call_os_plugin_function('remove_file',{'file_path':pid_file})
            self.call_os_plugin_function('remove_file',{'file_path':conf})
            self.call_os_plugin_function('remove_file',{'file_path':start_file})
            self.call_os_plugin_function('remove_file',{'file_path':lease_file})
            cmd = 'sudo ip link del {}'.format(dhcp_intf)
            self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':True})



        start_file, shutdown_file = self.net_files.get(network_uuid)
        shutdown_file = os.path.join(self.BASE_DIR, shutdown_file)
        start_file = os.path.join(self.BASE_DIR, start_file)
        self.call_os_plugin_function('execute_command',{'command':'sudo {}'.format(shutdown_file),'blocking':True, 'external':True})
        self.call_os_plugin_function('remove_file',{'file_path':shutdown_file})
        self.call_os_plugin_function('remove_file',{'file_path':start_file})
        # self.call_os_plugin_function('remove_file',{'file_path':dnsmasq_file})
        m  = self.networks.pop(network_uuid)
        m.update({'status':'DESTROY'})
        self.net_files.pop(network_uuid)
        self.connector.loc.actual.add_node_network(self.node, self.uuid, network_uuid, m)
        self.logger.info('delete_virtual_network()','Deleted {}'.format(network_uuid))

        return True

    def stop_network(self):
        keys = list(self.networks.keys())
        for k in keys:
            self.delete_virtual_network(k)
        return True

    def get_network_info(self, network_uuid):
        if network_uuid is None:
            return self.networks
        return self.networks.get(network_uuid)


    # FLOATING IPs #

    def create_floating_ip(self):
        self.logger.info('create_floating_ip()', 'Creating new floating IP')
        ip_id = '{}'.format(uuid.uuid4())
        ip_small_id = ip_id.split('-')[0]
        vface = 'fl-{}'.format(ip_small_id)
        face = self.overlay_interface
        cmd = "sudo ip link add {} link {} type macvlan mode vepa".format(vface, face)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':True})
        cmd = "sudo dhclient {}".format(vface)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':False, 'external':True})
        try:
            addr = netifaces.ifaddresses(vface)[2][0]['addr']
        except:
            self.logger.error('create_floating_ip()','Unable to retrieve address for floating interface')
            addr = ''
        float_record = {
            'uuid':ip_id,
            'ip_version':'IPV4',
            'address':addr,
            'face':face,
            'vface':vface,
            'cp_id':''
        }
        self.logger.info('create_floating_ip()',' [ DONE ] New floating IP created {}'.format(float_record))
        self.connector.loc.actual.add_node_floating_ip(self.node, self.uuid, ip_id, float_record)
        return {'result':float_record}

    def delete_floating_ip(self, ip_id):
        self.logger.info('delete_floating_ip()', 'Deting floating IP  {}'.format(ip_id))
        ip_small_id = ip_id.split('-')[0]
        vface = 'fl-{}'.format(ip_small_id)
        cmd = 'sudo ip link del {}'.format(vface)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':True})
        rec = self.connector.loc.actual.get_node_floating_ip(self.node, self.uuid, ip_id)
        self.connector.loc.actual.remove_node_floating_ip(self.node, self.uuid, ip_id)
        self.logger.info('delete_floating_ip()', '[DONE] Deletted IP {}'.format(ip_id))
        return {'result': rec}

    def assign_floating_ip(self, ip_id, cp_id):
        # fagent: [ERROR] [FOS-AGENT] - EV-ASSOC-FLOATING-IP - EXCEPTION: (Failure
        # "[YAS]:
        # EVAL on /alfos/a2d358aa-af2b-42cb-8d23-a89e88b97e5c/network_managers/d42b4163-af35-423a-acb4-a228290cf0be/exec/assign_floating_ip?(ip_id=c02eea4f-6f35-4a87-b8bb-b9ba617e8214;cp_id=a47a8819-72e5-4b4e-86fd-fc30c9fda68b):
        # ErrNo 400")
        self.logger.info('assign_floating_ip()', 'Assigning floating IP {} to {}'.format(ip_id, cp_id))
        rec = self.connector.loc.actual.get_node_floating_ip(self.node, self.uuid, ip_id)
        if rec is None:
            self.logger.error('assign_floating_ip()', 'Not found IP: {}'.format(ip_id))
            return {'error': 11}

        cp_ip = self.__get_cp_ip(cp_id)
        if cp_ip == '':
            self.logger.error('assign_floating_ip()', 'Connection point {} as not IP'.format(ip_id))
            return {'error': 11}
        cmd = 'sudo iptables -t nat -A PREROUTING -d {} -j DNAT --to {}'.format(rec['vface'], cp_ip)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':True})
        rec.update({'cp_id':cp_id})
        self.connector.loc.actual.add_node_floating_ip(self.node, self.uuid, ip_id, rec)
        self.logger.info('assign_floating_ip()', '[DONE] assigned floating IP {} to {}'.format(ip_id, cp_id))
        return {'result': rec}



    def remove_floating_ip(self, ip_id, cp_id):
        self.logger.info('remove_floating_ip()', 'Removing floating IP {} from {}'.format(ip_id, cp_id))
        rec = self.connector.loc.actual.get_node_floating_ip(self.node, self.uuid, ip_id)
        if rec is None:
            self.logger.error('remove_floating_ip()', 'Not found IP: {}'.format(ip_id))
            return {'error': 11}
        cp_ip = self.__get_cp_ip(cp_id)
        if cp_ip == '':
            self.logger.error('remove_floating_ip()', 'Connection point {} has no IP'.format(ip_id))
            return {'error': 11}
        cmd = 'sudo iptables -t nat -D PREROUTING -d {} -j DNAT --to {}'.format(rec['vface'], cp_ip)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':True})
        rec.update({'cp_id':''})
        self.connector.loc.actual.add_node_floating_ip(self.node, self.uuid, ip_id, rec)
        self.logger.info('remove_floating_ip()', '[DONE] removed floating IP {} from {}'.format(ip_id, cp_id))
        return {'result': rec}

    # ============ #


    def __get_cp_ip(self, cp_id):
        cp_rec = self.connector.loc.actual.get_node_port(self.node, self.uuid, cp_id)
        self.logger.info('__get_cp_ip()', 'Get connection point IP for {} Record: {}'.format(cp_id, cp_rec))
        fdus = self.connector.loc.actual.get_node_all_fdus_instances(self.node)
        cp_ip = ''
        for i in fdus:
            self.logger.info('__get_cp_ip()', 'Scanning FDUs Record: {}'.format(i))
            intfs = i['interfaces']
            for intf in intfs:
                if intf.get('cp_id') is not None and intf.get('cp_id') != '':
                    if intf.get('cp_id') == cp_rec['uuid']:
                        i_name = intf['vintf_name']
                        hv_info = i['hypervisor_info']
                        if len(hv_info) > 0:
                            cp_ip = hv_info['network'][i_name]['addresses'][0]['address']
        self.logger.info('__get_cp_ip()', 'IP for {} -> {}'.format(cp_id, cp_ip))
        return cp_ip

    def __cird2block(self, cird):
        '''
            Convert cird subnet to first address (for router), first dhcp, last dhcp, netmask

        :param cird:
        :return:
        '''
        (ip, cidr) = cird.split('/')
        cidr = int(cidr)
        host_bits = 32 - cidr
        netmask = socket.inet_ntoa(struct.pack(
            '!I', (1 << 32) - (1 << host_bits)))
        i = struct.unpack('>I', socket.inet_aton(ip))[0]
        start = (i >> host_bits) << host_bits
        end = i | ((1 << host_bits) - 1)

        return socket.inet_ntoa(struct.pack('>I', start + 1)), socket.inet_ntoa(
            struct.pack('>I', start + 2)), socket.inet_ntoa(struct.pack('>I', end - 1)), netmask

    def __get_net_size(self, netmask):
        binary_str = ''
        for octet in netmask:
            binary_str += bin(int(octet))[2:].zfill(8)
        return str(len(binary_str.rstrip('0')))

    def __ip_mask_to_cird(self, ip, mask):

        try:
            socket.inet_aton(ip)
            socket.inet_aton(mask)
        except:
            return "0.0.0.0/0"

        ip = ip.split('.')
        mask = mask.split('.')
        net_start = [str(int(ip[x]) & int(mask[x])) for x in range(0, 4)]
        return '.'.join(net_start) + '/' + self.__get_net_size(mask)


    def __net_observer(self, net_info):
        self.logger.info('__net_observer()', 'Linux Bridge Plugin - New Action of a Network - Net Info: {}'.format(net_info))
        action = net_info.get('status')
        net_uuid = net_info.get('uuid')
        if action == 'DESTROY':
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - This is a remove for : {}'.format(net_info))
            self.delete_virtual_network(net_uuid)
        elif action == 'CREATE':
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - This is a add for : {}'.format(net_info))
            self.create_virtual_network(net_info)
        else:
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - Action not recognized : {}'.format(action))


    def __port_observer(self, port_info):
        self.logger.info('__port_observer()', 'Linux Bridge Plugin - New Action of a Port - Port Info: {}'.format(port_info))
        action = port_info.get('status')
        port_uuid = port_info.get('uuid')
        if action == 'DESTROY':
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - This is a remove for : {}'.format(port_info))
            self.delete_port(port_uuid)
        elif action == 'CREATE':
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - This is a add for : {}'.format(port_info))
            self.create_port(port_info)
        else:
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - Action not recognized : {}'.format(action))


    def __router_observer(self, router_info):
        self.logger.info('__router_observer()', 'Linux Bridge Plugin - New Action of a Router - Router Info: {}'.format(router_info))
        action = router_info.get('state')
        router_uuid = router_info.get('uuid')
        if action == 'DESTROY':
            self.logger.info('__router_observer()', 'Linux Bridge Plugin - This is a remove for : {}'.format(router_info))
            self.delete_router(router_uuid)
        elif action == 'CREATE':
            self.logger.info('__router_observer()', 'Linux Bridge Plugin - This is a add for : {}'.format(router_info))
            self.create_router(router_info)
        else:
            self.logger.info('__router_observer()', 'Linux Bridge Plugin - Action not recognized : {}'.format(action))


    def __generate_interface_create_script(self, internal_name, external_name, name):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vface_creation.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(int_port=internal_name, ext_port=external_name)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'create_face_{}.sh'.format(name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_interface_destroy_script(self, external_name, name):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vface_destroy.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(ext_port=external_name)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'destroy_face_{}.sh'.format(name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name


    def __generate_port_create_script(self, internal_name, external_name, name):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'cp_creation.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(int_port=internal_name, ext_port=external_name, cp_name=name)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'create_port_{}.sh'.format(name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_port_destroy_script(self, external_name, name):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'cp_destroy.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(ext_port=external_name, cp_name=name)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'destroy_port_{}.sh'.format(name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name
# ########################## NEW SCRIPT CREATION FUNCTIONS:
    def __generate_vnet_start_script2(self, netid, net_uuid, vxlan_id, mcast_addr, overlay_interface):

        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_create.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid, group_id=vxlan_id, mcast_group_address=mcast_addr, wan=overlay_interface)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'start_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_vnet_stop_script2(self, netid):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_destroy.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'stop_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_vnet_vlan_start_script2(self, netid, net_uuid, vlan_id, vlan_face):

        vintf = '{}.{}'.format(vlan_face, vlan_id)
        if not self.check_if_interface_exists(vintf):
            self.create_vlan_interface(vlan_face, vlan_id)

        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_create_vlan.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)

        net_sh = net_sh.render(net_id=netid, vlan_intf=vintf)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'start_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_vnet_vlan_stop_script2(self, netid):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_destroy_vlan.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'stop_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name




# ###########################
    def __generate_vnet_start_script(self, netid, net_uuid):

        vxlan_id = self.__get_vni(net_uuid)
        mcast_addr = self.__get_mcast_addr(net_uuid)

        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_create.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        overlay_interface = self.overlay_interface
        net_sh = net_sh.render(net_id=netid, group_id=vxlan_id, mcast_group_address=mcast_addr, wan=overlay_interface)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'start_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_vnet_stop_script(self, netid):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_destroy.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'stop_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_vnet_vlan_start_script(self, netid, net_uuid):

        vlan_id = self.__get_vlan_id(net_uuid, self.vlan_range[0], self.vlan_range[1])
        mcast_addr = self.__get_mcast_addr(net_uuid)
        vintf = '{}.{}'.format(self.vlan_face, vlan_id)
        if not self.check_if_interface_exists(vintf):
            self.create_vlan_interface(self.vlan_face, vlan_id)

        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_create_vlan.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)

        net_sh = net_sh.render(net_id=netid, vlan_intf=vintf)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'start_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_vnet_vlan_stop_script(self, netid):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_destroy_vlan.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'stop_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name


    def __generate_dnsmaq_script(self, descriptor):
        net_uuid = descriptor.get('uuid')
        address_info = descriptor.get('ip_configuration')
        n_small_id = net_uuid.split('-')[0]
        vdev_name = 'br-{}'.format(n_small_id)
        netns_name = 'fosns-{}'.format(n_small_id)
        path = os.path.join(self.BASE_DIR, self.DHCP_DIR)

        template_conf = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'dnsmasq.conf'), 'root':False})

        dhcp_intf = 'dhcp-{}-i'.format(n_small_id)
        lease_file = os.path.join(path,'net_{}_leases'.format(n_small_id))
        pid_file =  os.path.join(path,'net_{}.pid'.format(n_small_id))
        conf = 'net_{}.conf'.format(n_small_id)
        start_file = 'dhcp_{}.sh'.format(n_small_id)
        addrs = self.__cird2block(address_info.get('subnet'))


        dnsmasq_conf = Environment().from_string(template_conf)
        dnsmasq_conf = dnsmasq_conf.render(dhcpinterface=dhcp_intf, lease_file=lease_file,dhcppid=pid_file)
        if address_info.get('dhcp_range') is not None and address_info.get('dhcp_enable') :
            dnsmasq_conf = dnsmasq_conf+'\ndhcp-range={},86400s'.format(address_info.get('dhcp_range'))
        else:
            #dnsmasq_conf = dnsmasq_conf+'\ndhcp-range={},static,86400s'.format(address_info.get('subnet').split('/')[0])
            dnsmasq_conf = dnsmasq_conf+'\ndhcp-range={},{},86400s'.format(addrs[1], addrs[2])
        if address_info.get('gateway') is not None:
            dnsmasq_conf = dnsmasq_conf+'\ndhcp-option=3,{}'.format(address_info.get('gateway'))
        if address_info.get('dns') is not None:
            dnsmasq_conf = dnsmasq_conf+'\ndhcp-option=6,{}'.format(address_info.get('dns'))

        dnsmasq_conf = binascii.hexlify(base64.b64encode(bytes(dnsmasq_conf,'utf-8'))).decode()
        self.call_os_plugin_function('store_file',{'content':dnsmasq_conf, 'file_path':path, 'filename':conf})

        template_start = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'dnsmasq.sh'), 'root':False})
        dnsmasq_sh = Environment().from_string(template_start)

        dns_face_ip = address_info.get('subnet').split('/')[0]
        dnsmasq_sh = dnsmasq_sh.render(netid=n_small_id, dhcp_conf_path=os.path.join(path, conf), ip=dns_face_ip, mask=addrs[-1])
        dnsmasq_sh = binascii.hexlify(base64.b64encode(bytes(dnsmasq_sh,'utf-8'))).decode()
        self.call_os_plugin_function('store_file',{'content':dnsmasq_sh, 'file_path':path, 'filename':start_file})

        chmod_cmd = 'chmod +x {}'.format(os.path.join(path, start_file))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return start_file

    # def __generate_dnsmaq_script(self, descriptor):
    #     net_uuid = descriptor.get('uuid')
    #     address_info = descriptor.get('ip_configuration')
    #     n_small_id = net_uuid.split('-')[0]
    #     vdev_name = 'br-{}'.format(n_small_id)
    #     netns_name = 'fosns-{}'.format(n_small_id)
    #     path = os.path.join(self.BASE_DIR, self.DHCP_DIR)

    #     template_conf = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'dnsmasq.conf'), 'root':False})

    #     dhcp_intf = 'dhcp-{}-i'.format(n_small_id)
    #     lease_file = os.path.join(path,'net_{}_leases'.format(n_small_id))
    #     pid_file =  os.path.join(path,'net_{}.pid'.format(n_small_id))
    #     conf = 'net_{}.conf'.format(n_small_id)
    #     start_file = 'dhcp_{}.sh'.format(n_small_id)



    #     dnsmasq_conf = Environment().from_string(template_conf)
    #     dnsmasq_conf = dnsmasq_conf.render(dhcpinterface=dhcp_intf, lease_file=lease_file,dhcppid=pid_file)
    #     if address_info.get('dhcp_range') is not None and address_info.get('dhcp_enable') :
    #         dnsmasq_conf = dnsmasq_conf+'\ndhcp-range={},86400s'.format(address_info.get('dhcp_range'))
    #     else:
    #         dnsmasq_conf = dnsmasq_conf+'\ndhcp-range={},static,86400s'.format(address_info.get('subnet').split('/')[0])
    #     if address_info.get('gateway') is not None:
    #         dnsmasq_conf = dnsmasq_conf+'\ndhcp-option=3,{}'.format(address_info.get('gateway'))
    #     if address_info.get('dns') is not None:
    #         dnsmasq_conf = dnsmasq_conf+'\ndhcp-option=6,{}'.format(address_info.get('dns'))

    #     dnsmasq_conf = binascii.hexlify(base64.b64encode(bytes(dnsmasq_conf,'utf-8'))).decode()
    #     self.call_os_plugin_function('store_file',{'content':dnsmasq_conf, 'file_path':path, 'filename':conf})

    #     template_start = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'dnsmasq.sh'), 'root':False})
    #     dnsmasq_sh = Environment().from_string(template_start)
    #     addrs = self.__cird2block(address_info.get('subnet'))
    #     dnsmasq_sh = dnsmasq_sh.render(netid=n_small_id, dhcp_conf_path=os.path.join(path, conf), ip=addrs[0], mask=addrs[-1])
    #     dnsmasq_sh = binascii.hexlify(base64.b64encode(bytes(dnsmasq_sh,'utf-8'))).decode()
    #     self.call_os_plugin_function('store_file',{'content':dnsmasq_sh, 'file_path':path, 'filename':start_file})

    #     chmod_cmd = 'chmod +x {}'.format(os.path.join(path, start_file))
    #     self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
    #     return start_file


    def __generate_vxlan_shutdown_script(self, net_uuid):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vxlan_destroy.sh'), 'root':False})
        br_name = 'br-{}'.format(net_uuid.split('-')[0])
        vxlan_name = 'vxl-{}'.format(net_uuid.split('-')[0])
        file_name = '{}_dnsmasq.pid'.format(br_name)
        pid_file_path = os.path.join(self.BASE_DIR, self.DHCP_DIR, file_name)
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(
            bridge=br_name, vxlan_intf_name=vxlan_name, dnsmasq_pid_file=pid_file_path)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        self.logger.info('__generate_port_create_script()', 'File content : {}'.format(net_sh))
        file_name = '{}_stop.sh'.format(br_name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':file_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, file_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})

        return file_name


    def __generate_vxlan_script(self, net_uuid, manifest=None):
        if not self.overlay_interface:
            template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vxlan_creation.sh'), 'root':False})
        else:
            template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vxlan_creation_intf.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        br_name = 'br-{}'.format(net_uuid.split('-')[0])
        vxlan_name = 'vxl-{}'.format(net_uuid.split('-')[0])

        if manifest is not None:
            if manifest.get('overlay_info') is not None and manifest.get('overlay_info').get('vxlan_id') is not None:
                vxlan_id = manifest.get('overlay_info').get('vxlan_id')
            else:
                vxlan_id = len(self.networks) + 1
            if manifest.get('overlay_info') is not None and manifest.get('overlay_info').get('multicast_address') is not None:
                mcast_addr = manifest.get(
                    'overlay_info').get('multicast_address')
            else:
                mcast_addr = '239.0.0.{}'.format(vxlan_id)
        else:
            vxlan_id = len(self.networks) + 1
            mcast_addr = '239.0.0.{}'.format(vxlan_id)

        net_sh = net_sh.render(bridge_name=br_name, vxlan_intf_name=vxlan_name,
                               group_id=vxlan_id, mcast_group_address=mcast_addr, wan=self.overlay_interface)

        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = '{}.sh'.format(net_uuid.split('-')[0])
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name, vxlan_name, vxlan_id, mcast_addr

    def __get_mcast_addr(self, net_id):
        hashdata = hashlib.sha512(net_id.encode('utf8')).digest()
        return '239.245.{}.{}'.format(hashdata[0],hashdata[-1])

    def __get_vni(self, net_id):
        hashdata = hashlib.sha512(net_id.encode('utf8')).digest()
        vni = 0
        for x in hashdata:
            vni += x
        return vni % VNI_LIMIT

    def __get_vlan_id(self, net_id, min_id=0, max_id=VLAN_LIMIT):
        hashdata = hashlib.sha512(net_id.encode('utf8')).digest()
        vlid = 0
        for x in hashdata:
            vlid += x
        vlanid = (vlid % max_id) + min_id
        self.logger.info('__get_vlan_id()', 'Range : {} - {} ID: {}'.format(min_id, max_id, vlanid))
        return vlanid


def read_file(file_path):
    data = ''
    with open(file_path, 'r') as f:
        data = f.read()
    return data


if __name__ == '__main__':
    if len(sys.argv) < 2:
        exit(-1)
    print('ARGS {}'.format(sys.argv))
    file_dir = os.path.dirname(__file__)
    manifest = json.loads(read_file(sys.argv[1]))
    nm = LinuxBridge(manifest.get('name'), manifest.get('version'), manifest.get(
        'uuid'), manifest)
    nm.start_network_manager()
