#!/usr/bin/env python3

# Copyright (c) 2014,2018 ADLINK Technology Inc.
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
# which is available at https://www.apache.org/licenses/LICENSE-2.0.
#
# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
#
# Contributors: Gabriele Baldoni, ADLINK Technology Inc. - Base plugins set


#
# This plugin use Full LinuxBridge implementation for
# connection points and virtual links
#

import sys
import os
import uuid
import struct
import json
import socket
import signal
import hashlib
import psutil
import netifaces
from jinja2 import Environment
from fog05.interfaces.NetworkPlugin import *
from fog05 import Yaks_Connector
from mvar import MVar
from fog05.DLogger import DLogger

VNI_LIMIT = 16777215
VLAN_LIMIT = 4095

class LinuxBridge(NetworkPlugin):

    def __init__(self, name, version, plugin_uuid, manifest):

        super(LinuxBridge, self).__init__(version, plugin_uuid)
        self.name = name
        loc = manifest.get('configuration').get('ylocator').split('/')[1]
        self.connector = Yaks_Connector(loc)
        self.logger = DLogger(debug_flag=True)
        self.node = manifest.get('configuration').get('nodeid')
        self.manifest = manifest
        self.configuration = manifest.get('configuration', {})
        self.pid = os.getpid()
        self.var = MVar()
        self.agent_conf = self.connector.loc.actual.get_node_configuration(self.node)
        self.use_vlan = self.configuration.get('use_vlan', False)
        self.vlan_face = self.configuration.get('vlan_interface', None)
        self.vlan_range = self.configuration.get('vlan_range', [0, VLAN_LIMIT])

        self.wait_dependencies()
        self.logger.info('__init__()', ' Hello from Linux Bridge Plugin')



        self.BASE_DIR = os.path.join(
            self.agent_conf.get('agent').get('path'), 'linuxbridge')

        self.DHCP_DIR = 'dhcp'
        self.HOME = 'network/{}'.format(self.uuid)
        file_dir = os.path.dirname(__file__)
        self.DIR = os.path.abspath(file_dir)
        self.overlay_interface = manifest.get('configuration').get('dataplane_interface')
        if self.overlay_interface is None:
            self.agent_conf.get('agent').get('mgmt_interface')

        if self.vlan_face is None:
            self.vlan_face = self.overlay_interface

        self.networks = {}
        self.net_files = {}
        self.intfs = {}
        self.ports = {}
        self.bridges = {}
        self.routers = {}
        self.floating_ips = {}

        signal.signal(signal.SIGINT, self.__catch_signal)
        signal.signal(signal.SIGTERM, self.__catch_signal)

    def __catch_signal(self, signal, _):
        if signal in [2, 15]:
            self.var.put(signal)

    def start_network_manager(self):
        self.logger.info('start_runtime()', 'Linux Bridge Plugin - Starting...')

        if self.os.dir_exists(self.BASE_DIR):
            if not self.os.dir_exists(os.path.join(self.BASE_DIR, self.DHCP_DIR)):
                self.os.create_dir(os.path.join(self.BASE_DIR, self.DHCP_DIR))
        else:
            self.os.create_dir(os.path.join(self.BASE_DIR))
            self.os.create_dir(os.path.join(self.BASE_DIR, self.DHCP_DIR))

        if self.overlay_interface is None:
            self.agent_conf.get('agent').get('mgmt_interface')

        if self.overlay_interface is None or self.overlay_interface == 'None':
            self.logger.error('start_network_manager()','Data plane interface cannot be None!')
            exit(-1)

        d = {
            'create_virtual_interface': self.create_virtual_interface,
            'delete_virtual_interface': self.delete_virtual_interface,
            'create_virtual_bridge': self.create_virtual_bridge,
            'delete_virtual_bridge': self.delete_virtual_bridge,
            'create_bridges_if_not_exist': self.create_bridges_if_not_exist,
            'connect_interface_to_connection_point': self.connect_interface_to_connection_point,
            'disconnect_interface': self.disconnect_interface,
            'connect_cp_to_vnetwork': self.connect_cp_to_vnetwork,
            'disconnect_cp': self.disconnect_cp,
            'delete_port': self.delete_port,
            'get_address': self.get_address,
            'add_router_port': self.add_port_to_router,
            'remove_router_port': self.remove_port_from_router,
            'create_floating_ip': self.create_floating_ip,
            'delete_floating_ip': self.delete_floating_ip,
            'assign_floating_ip': self.assign_floating_ip,
            'remove_floating_ip': self.remove_floating_ip,
            # utility functions
            'get_overlay_interface': self.get_overlay_face,
            'get_vlan_interface': self.get_vlan_face,
            # fuctions called by agent for CPs
            'create_port_agent': self.create_port_from_descriptor,
            'destroy_port_agent':self.destroy_port_agent,
        }

        for k in d:
            f = d.get(k)
            self.logger.info(
                '__init__()', 'Linux Bridge Plugin - Registering {}'.format(k))
            self.connector.loc.actual.add_nw_eval(self.node, self.uuid, k, f)

        self.connector.loc.desired.observe_node_networks(
            self.node, self.uuid, self.__net_observer)
        self.connector.loc.desired.observe_node_ports(
            self.node, self.uuid, self.__port_observer)
        self.connector.loc.desired.observe_node_routers(
            self.node, self.uuid, self.__router_observer)
        self.manifest.update({'pid': self.pid})
        self.manifest.update({'status': 'running'})
        self.connector.loc.actual.add_node_plugin(
            self.node, self.uuid, self.manifest)

        self.logger.info('start_runtime()', 'Linux Bridge Plugin - Data Plane (VxLAN) Interface {}'.format(self.overlay_interface))
        if self.use_vlan:
            self.logger.info('start_runtime()', 'Linux Bridge Plugin - VLAN Interface {}'.format(self.vlan_face))
            self.logger.info('start_runtime()', 'Linux Bridge Plugin - VLAN Range {}'.format(self.vlan_range))
        self.logger.info('start_runtime()', 'Linux Bridge Plugin - Started...')

        r = self.var.get()
        self.stop_network_manager()
        self.connector.close()
        exit(0)

    def stop_network_manager(self):
        for k in list(self.intfs.keys()):
            self.delete_virtual_interface(k)
        for k in list(self.ports.keys()):
            self.delete_port(k)
        for k in list(self.networks.keys()):
            self.delete_virtual_network(k)
        for k in list(self.bridges.keys()):
            self.delete_virtual_bridge(k)
        for k in list(self.routers.keys()):
            self.delete_router(k)
        for k in list(self.floating_ips.keys()):
            self.delete_floating_ip(k)


    def get_overlay_face(self):
        return {'result': self.overlay_interface}

    def get_vlan_face(self):
        return {'result': self.vlan_face}

    def get_address(self, mac_address):
        self.logger.info('get_address()', 'Linux Bridge Plugin - Getting IP address for  {}'.format(mac_address))
        if mac_address == '':
            return {'result': ''}

        # LEASE FILE FORMAT
        # 1560518377 00:16:3e:5e:a8:fa 192.168.123.13 holy-gar 01:00:16:3e:5e:a8:fa

        for netid in self.networks:
            net = self.networks[netid]
            if net.get('ip_configuration') is not None:
                n_small_id = netid.split('-')[0]
                path = os.path.join(self.BASE_DIR, self.DHCP_DIR)
                lease_file = os.path.join(path,'net_{}_leases'.format(n_small_id))
                if self.os.file_exists(lease_file):
                    res = self.os.read_file(lease_file).split('\n')
                    for l in res:
                        tok = l.split(' ')
                        if len(tok) >= 2:
                            if tok[1] == mac_address:
                                self.logger.info('get_address()', 'Linux Bridge Plugin - IP address for {} is {}'.format(mac_address, tok[2]))
                                return {'result': tok[2]}
                        else:
                            self.logger.info('get_address()', 'Linux Bridge Plugin - Unable to get IP address for {} '.format(mac_address))
                            return {'result': ''}

        self.logger.info('get_address()', 'Linux Bridge Plugin - Unable to get IP address for {} '.format(mac_address))
        return {'result': ''}



    # todo: last item is empty-> delete
    def get_bridge_names_from_output_string(self, output):
        rows = output.split('\n')
        table = [row.split('\t') for row in rows]
        bridges_names = [item[0] for item in table]
        return bridges_names[1:]  # pop name of the table

    def get_virtual_bridges_in_node(self):
        cmd = 'sudo brctl show'
        output = self.os.execute_command(cmd,blocking=True,external=False)
        return self.get_bridge_names_from_output_string(output)

    # this is an eval
    def create_bridges_if_not_exist(self, expected_bridges):
        expected_bridges = json.loads(expected_bridges)
        current_bridges = self.get_virtual_bridges_in_node()
        for bridge in expected_bridges:
            if bridge not in current_bridges:
                self.create_virtual_bridge(bridge, '{}'.format(uuid.uuid4()))
        return {'result':expected_bridges}


    def check_if_interface_exists(self, iface):
        faces = psutil.net_if_addrs()
        if faces.get(iface, None) is None:
            return False
        return True

    def create_vlan_interface(self, iface, vlanid):
        cmd = 'sudo ip link add link {} name {}.{} type vlan id {}'.format(iface, iface, vlanid, vlanid)
        self.os.execute_command(cmd,blocking=True, external=True)

    # this is an eval
    def create_virtual_interface(self,intf_id, descriptor):
        self.logger.info('create_virtual_interface','Creating {}'.format(intf_id))
        descriptor = json.loads(descriptor)
        intf_name = intf_id
        internal_name = '{}-i'.format(intf_id)
        external_name = '{}-e'.format(intf_id)
        start_file = self.__generate_interface_create_script(internal_name, external_name, intf_name)
        stop_file = self.__generate_interface_destroy_script(external_name, intf_name)
        cmd_start = os.path.join(self.BASE_DIR, start_file)
        cmd_stop = os.path.join(self.BASE_DIR, stop_file)
        self.os.execute_command(cmd_start,blocking=True, external=True)
        descriptor.update({'intf_id':intf_id})
        self.logger.info('create_virtual_interface','Created {}'.format(intf_id))


        intf_info = {
            'descriptor':descriptor,
            'int_name': internal_name,
            'ext_name':external_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        self.intfs.update({intf_id: intf_info})
        if descriptor.get('cp_id') is not None:
            cpid = descriptor.get('cp_id')
            self.logger.info('create_virtual_interface','Attach to {}'.format(cpid))
            self.connect_interface_to_connection_point(intf_id, cpid)
            self.logger.info('create_virtual_interface','Attached to {}'.format(cpid))
        return {'result':intf_info}

    # this is an eval
    def delete_virtual_interface(self, intf_id):
        self.logger.info('delete_virtual_interface','{} has to be deleted'.format(intf_id))
        intf_info = self.intfs.get(intf_id)
        if intf_info is None:
            self.logger.error('delete_virtual_interface','{} does not exist'.format(intf_id))
            return {'error':12}
        stop_file = intf_info.get('stop')
        if intf_info.get('descriptor').get('cp_id') is not None:
            cpid = intf_info.get('descriptor').get('cp_id')
            self.disconnect_interface(intf_id)
        self.os.execute_command(stop_file,blocking=True, external=True)
        self.os.remove_file(stop_file)
        self.os.remove_file(intf_info.get('start'))
        self.intfs.pop(intf_id)
        self.logger.info('delete_virtual_interface','{} removed'.format(intf_id))
        return {'result':intf_id}

    # this is an eval
    def create_virtual_bridge(self, name, uuid):
        cmd = 'sudo ip link add {} type bridge'.format(name)
        self.os.execute_command(cmd,blocking=True, external=False)
        br_uuid = uuid
        self.bridges.update({br_uuid: name})
        return {'result':{'uuid':br_uuid, 'name':name}}


    # this is an eval
    def delete_virtual_bridge(self, br_uuid):
        self.logger.info('delete_virtual_bridge', 'Removing {}'.format(br_uuid))
        name = self.bridges.get(br_uuid)
        if name is None:
            self.logger.error('delete_virtual_bridge', 'Bridge {} not existing'.format(br_uuid))
            return {'error':-2}
        cmd = 'sudo ip link del {}'.format(name)
        self.os.execute_command(cmd, blocking=True, external=False)
        self.bridges.pop(br_uuid)
        self.logger.info('delete_virtual_bridge', 'Removed {}'.format(br_uuid))
        return {'result':br_uuid}

    def create_port(self, record):
        cp_id = record.get('uuid')
        # descriptor = self.agent.get_port_info(record.get('cp_uuid'))
        cp_small_id = ''.join([x[0] for x in cp_id.split('-')])
        cp_name = 'br-cp-{}'.format(cp_small_id)
        int_name = 'cp-{}-i'.format(cp_small_id)
        ext_name = 'cp-{}-e'.format(cp_small_id)
        self.logger.info('create_port', 'Creating {} {} {}'.format(cp_name, int_name, ext_name))
        start_file = self.__generate_port_create_script(int_name, ext_name, cp_name)
        stop_file = self.__generate_port_destroy_script(ext_name, cp_name)
        cmd_start = os.path.join(self.BASE_DIR, start_file)
        cmd_stop = os.path.join(self.BASE_DIR, stop_file)
        self.os.execute_command(cmd_start,blocking=True, external=True)
        cp_info = {
            'descriptor':record,
            'int_name': int_name,
            'ext_name':ext_name,
            'cp_name':cp_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        self.ports.update({cp_id: cp_info})
        if record.get("vld_ref") is not None:
            pair_id = record.get("vld_ref")
            self.connect_cp_to_vnetwork(cp_id, pair_id)
        properties = {
            'int_name': int_name,
            'ext_name':ext_name,
            'cp_name':cp_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        record.update({'status':'CREATE'})
        record.update({'properties':properties})
        self.connector.loc.actual.add_node_port(self.node, self.uuid, cp_id,record)


    def delete_port(self, cp_id):
        port_info = self.ports.get(cp_id)
        if port_info is None:
            self.logger.error('delete_port','{} does not exist'.format(cp_id))
            return False
        stop_file = port_info.get('stop')
        if port_info.get('descriptor').get('vld_ref') is not None:
            pair_id = port_info.get('descriptor').get('vld_ref')
            self.disconnect_cp(cp_id)
        self.os.execute_command(stop_file,blocking=True, external=True)
        self.os.remove_file(stop_file)
        self.os.remove_file(port_info.get('start'))
        self.ports.pop(cp_id)
        self.connector.loc.actual.remove_node_port(self.node, self.uuid, cp_id)


    def create_router(self, record):
        router_id = record.get('uuid')
        self.logger.info('create_router()', 'Creating {} Record: {}'.format(router_id, record))
        # {
        #   'uuid':'12345678-1234-1234-1234-123456789012',
        #   'state':'CREATE',
        #   'router_ns': 'r-12345678-ns',
        #   'nodeid': ''12345678-1234-1234-1234-123456789012',
        #   'ports': [
        #       {
        #          'port_type':'EXTERNAL',
        #          'ext_face':'ens2',
        #          'ip_address':'',
        #          'faces':['r-12345678-e0']
        #       },
        #       {
        #          'port_type':'INTERNAL',
        #          'faces': [ 'r-12345678-e1-i', 'r-12345678-e1-e'],
        #          'ip_address': '192.168.123.1/24',
        #          'pair_id': '12345678-1234-1234-1234-123456789012'
        #       }
        #   ]
        # }

        self.logger.info('create_router()', 'Creating Router NS: {}'.format(record['router_ns']))
        cmd_new_ns = 'sudo ip netns add {}'.format(record['router_ns'])
        cmd_ns_forwarding = 'sudo ip netns exec {} sysctl -w net.ipv4.ip_forward=1'.format(record['router_ns'])
        self.os.execute_command(cmd_new_ns, blocking=True, external=True)
        self.os.execute_command(cmd_ns_forwarding, blocking=True, external=True)

        # Sorting ports to have always the same order
        ports = sorted(record['ports'], key=lambda k: k['port_type']+k['faces'][0])
        record.update({'ports': ports})

        ext_face = ports[0]['faces'][0]


        for p in record['ports']:

            if p['port_type'] == 'EXTERNAL':
                cmd_add_macvlan = 'sudo ip link add {} link {} type macvlan mode vepa'.format(p['faces'][0], p['ext_face'])
                cmd_port_to_ns = 'sudo ip link set {} netns {}'.format(p['faces'][0], record['router_ns'])
                cmd_port_up = 'sudo ip netns exec {} ip link set {} up'.format(record['router_ns'], p['faces'][0])

                self.logger.info('create_router()', 'Creating EXTERNAL PORT: {} and assiging to router NS {}'.format(p['faces'][0], record['router_ns']))
                self.os.execute_command(cmd_add_macvlan, blocking=True, external=True)
                self.os.execute_command(cmd_port_to_ns, blocking=True, external=True)
                self.os.execute_command(cmd_port_up, blocking=True, external=True)
                if p['ip_address'] == '':

                    self.logger.info('create_router()', 'Asking address for face: {}'.format(p['faces'][0]))

                    cmd_dhcp_client = 'sudo ip netns exec {} dhclient {}'.format(record['router_ns'], p['faces'][0])
                    self.os.execute_command(cmd_dhcp_client, blocking=True, external=True)

                    cmd_get_address = 'sudo ip netns exec {} fos_get_address {}'.format(record['router_ns'], p['faces'][0])

                    addr = self.os.execute_command(cmd_get_address, blocking=True, external=False)
                    self.logger.info('create_router()', 'Returing: {}'.format(addr))


                    p.update({'ip_address':addr})
                else:
                    self.logger.info('create_router()', 'Assing {} address for face: {}'.format(p['ip_address'], p['faces'][0]))
                    cmd_add_addr = 'sudo ip netns exec {} ip addr add {} dev {}'.format(record['router_ns'], p['ip_address'], p['faces'][0])
                    self.os.execute_command(cmd_add_addr, blocking=True, external=True)
                self.logger.info('create_router()', 'Router EXTERNAL PORT Created: {}'.format(p['faces'][0]))


            elif p['port_type'] == 'INTERNAL':
                self.logger.info('create_router()', 'Creating INTERNAL PORT: {}<->{}'.format(p['faces'][0], p['faces'][1]))

                cmd_veth_pair = 'sudo ip link add {} type veth peer name {}'.format(p['faces'][0], p['faces'][1])
                cmd_i_face_to_ns = 'sudo ip link set {} netns {}'.format(p['faces'][0], record['router_ns'])
                cmd_i_face_up = 'sudo ip netns exec {} ip link set {} up'.format(record['router_ns'], p['faces'][0])

                self.os.execute_command(cmd_veth_pair, blocking=True, external=True)
                self.os.execute_command(cmd_i_face_to_ns, blocking=True, external=True)
                self.os.execute_command(cmd_i_face_up, blocking=True, external=True)

                net_record = self.networks.get(p['vnet_id'])
                net_ns = net_record['properties']['net_ns']
                net_dev = net_record['properties']['virtual_device'] + '-ns'

                cmd_e_face_to_ns = 'sudo ip link set {} netns {}'.format(p['faces'][1], net_ns)
                cmd_e_face_up = 'sudo ip netns exec {} ip link set {} up'.format(net_ns, p['faces'][1])
                cmd_e_face_master = 'sudo ip netns exec {} ip link set {} master {}'.format(net_ns, p['faces'][1], net_dev)

                self.os.execute_command(cmd_e_face_to_ns, blocking=True, external=True)
                self.os.execute_command(cmd_e_face_up, blocking=True, external=True)
                self.os.execute_command(cmd_e_face_master, blocking=True, external=True)



                if p['ip_address'] == '':

                    self.logger.info('create_router()', 'Asking address for face: {}'.format(p['faces'][0]))
                    cmd_dhcp_client = 'sudo ip netns exec {} dhclient {}'.format(record['router_ns'],p['faces'][0])
                    self.os.execute_command(cmd_dhcp_client, blocking=True, external=True)

                    cmd_get_address = 'sudo ip netns exec {} fos_get_address {}'.format(record['router_ns'], p['faces'][0])

                    addr = self.os.execute_command(cmd_get_address, blocking=True, external=False)

                    p.update({'ip_address':addr.strip()})
                else:
                    self.logger.info('create_router()', 'Assing {} address for face: {}'.format(p['ip_address'], p['faces'][0]))
                    cmd_add_addr = 'sudo ip netns exec {} ip addr add {} dev {}'.format(record['router_ns'], p['ip_address'], p['faces'][0])
                    self.os.execute_command(cmd_add_addr, blocking=True, external=True)

                self.logger.info('create_router()', 'Setting iptables rules...')

                cmd_iptables_nat = 'sudo ip netns exec {} iptables -t nat -A POSTROUTING -s {} -o {} -j MASQUERADE'.format(record['router_ns'], p['ip_address'], ext_face)
                cmd_iptables_forward_in = 'sudo ip netns exec {} iptables -A FORWARD -i {} -o {} -j ACCEPT'.format(record['router_ns'], ext_face, p['faces'][0])
                cmd_iptables_forward_out = 'sudo ip netns exec {} iptables -A FORWARD -o {} -i {} -j ACCEPT'.format(record['router_ns'], ext_face, p['faces'][0])

                self.os.execute_command(cmd_iptables_nat, blocking=True, external=True)
                self.os.execute_command(cmd_iptables_forward_in, blocking=True, external=True)
                self.os.execute_command(cmd_iptables_forward_out, blocking=True, external=True)


            else:
                self.logger.error('create_router()', 'Router port_type is not recognized: {}'.format(p['port_type']))

        self.logger.info('create_router()', 'Router {} created!'.format(router_id))
        self.routers.update({router_id: record})
        self.connector.loc.actual.add_node_router(self.node, self.uuid, router_id, record)


    def delete_router(self, router_id):
        router_info = self.routers.get(router_id)
        if router_info is None:
            self.logger.error('delete_router()','Router {} does not exist'.format(router_id))
            return False
        self.logger.info('delete_router()', 'Removing Router {}'.format(router_id))
        for p in router_info['ports']:
            if p['port_type'] == 'EXTERNAL':
                self.logger.info('delete_router()', 'Removing External Face {}'.format(p['faces'][0]))
                cmd_remove_face = 'sudo ip netns exec {} ip link del {}'.format(router_info['router_ns'], p['faces'][0])

                self.os.execute_command(cmd_remove_face, blocking=True, external=True)


                self.logger.info('delete_router()', 'Removed External Face {}'.format(p['faces'][0]))

            elif p['port_type'] == 'INTERNAL':
                self.logger.info('delete_router()', 'Removing Internal Face {}'.format(p['faces'][0]))

                net_record = self.networks.get(p['vnet_id'])
                net_ns = net_record['properties']['net_ns']

                cmd_remove_face = 'sudo ip netns exec {} ip link del {}'.format(net_ns, p['faces'][1])

                self.os.execute_command(cmd_remove_face, blocking=True, external=True)

                self.logger.info('delete_router()', 'Removed Internal Face {}'.format(p['faces'][0]))
            else:
                self.logger.error('create_router()', 'Router port_type is not recognized: {}'.format(p['port_type']))



        cmd_ns_rem = 'sudo ip netns del {}'.format(router_info['router_ns'])
        self.os.execute_command(cmd_ns_rem, blocking=True, external=True)


        self.logger.info('delete_router()', 'Router {} deleted'.format(router_id))
        self.routers.pop(router_id)
        self.connector.loc.actual.remove_node_router(self.node, self.uuid, router_id)

    def add_port_to_router(self, router_id, port_type, vnet_id=None, ip_address=None):
        self.logger.info('add_port_to_router()', 'Adding port to router {}'.format(router_id))
        record = self.routers.get(router_id)

        if record is None:
            self.logger.error('add_port_to_router()','Router {} does not exist'.format(router_id))
            return {'error': 404}

        self.logger.info('add_port_to_router()', 'Sorting ports')
        # Sorting ports to have always the same order
        ports = sorted(record['ports'], key=lambda k: k['port_type']+k['faces'][0])
        record.update({'ports': ports})

        self.logger.info('add_port_to_router()', 'Selecting external face ports')
        ext_face = ports[0]['faces'][0]

        # getting next port id
        self.logger.info('add_port_to_router()', 'Selecting new port id')
        if ports[-1]['port_type'] == 'INTERNAL':
            port_id = int(ports[-1]['faces'][0][12:-2])+1
        else:
            port_id = int(ports[-1]['faces'][0][12:])+1


        if port_type.upper() == 'EXTERNAL':
            pass
        elif port_type.upper() == 'INTERNAL' and vnet_id is not None:
            self.logger.info('add_port_to_router()', 'Adding INTERNAL port to router {}'.format(router_id))

            net_record = self.networks.get(vnet_id)
            net_ns = net_record['properties']['net_ns']
            net_dev = net_record['properties']['virtual_device'] + '-ns'

            iface = 'r-{}-e{}-i'.format(router_id.split('-')[0], port_id)
            eface = 'r-{}-e{}-e'.format(router_id.split('-')[0], port_id)

            cmd_veth_pair = 'sudo ip link add {} type veth peer name {}'.format(iface, eface)
            cmd_i_face_to_ns = 'sudo ip link set {} netns {}'.format(iface, record['router_ns'])
            cmd_i_face_up = 'sudo ip netns exec {} ip link set {} up'.format(record['router_ns'], iface)

            self.os.execute_command(cmd_veth_pair, blocking=True, external=True)
            self.os.execute_command(cmd_i_face_to_ns, blocking=True, external=True)
            self.os.execute_command(cmd_i_face_up, blocking=True, external=True)

            cmd_e_face_to_ns = 'sudo ip link set {} netns {}'.format(eface, net_ns)
            cmd_e_face_up = 'sudo ip netns exec {} ip link set {} up'.format(net_ns, eface)
            cmd_e_face_master = 'sudo ip netns exec {} ip link set {} master {}'.format(net_ns, eface, net_dev)

            self.os.execute_command(cmd_e_face_to_ns, blocking=True, external=True)
            self.os.execute_command(cmd_e_face_up, blocking=True, external=True)
            self.os.execute_command(cmd_e_face_master, blocking=True, external=True)

            port_record = {
                'port_type':port_type.upper(),
                'faces':[iface, eface],
                'pair_id': vnet_id,
            }

            if ip_address is None or ip_address == '':

                self.logger.info('add_port_to_router()', 'Asking address for face: {}'.format(iface))
                cmd_dhcp_client = 'sudo ip netns exec {} dhclient {}'.format(record['router_ns'], iface)
                self.os.execute_command(cmd_dhcp_client, blocking=True, external=True)

                cmd_get_address = 'sudo ip netns exec {} fos_get_address {}'.format(record['router_ns'], iface)

                addr = self.os.execute_command(cmd_get_address, blocking=True)

                port_record.update({'ip_address':addr.strip().replace("\\n","")})
            else:
                self.logger.info('add_port_to_router()', 'Assing {} address for face: {}'.format(ip_address, iface))
                cmd_add_addr = 'sudo ip netns exec {} ip addr add {} dev {}'.format(record['router_ns'], ip_address, iface)
                self.os.execute_command(cmd_add_addr, blocking=True, external=True)
                port_record.update({'ip_address':ip_address})

            self.logger.info('add_port_to_router()', 'Setting iptables rules...')

            record['ports'].append(port_record)

            cmd_iptables_nat = 'sudo ip netns exec {} iptables -t nat -A POSTROUTING -s {} -o {} -j MASQUERADE'.format(record['router_ns'], ip_address, ext_face)
            cmd_iptables_forward_in = 'sudo ip netns exec {} iptables -A FORWARD -i {} -o {} -j ACCEPT'.format(record['router_ns'], ext_face, iface)
            cmd_iptables_forward_out = 'sudo ip netns exec {} iptables -A FORWARD -o {} -i {} -j ACCEPT'.format(record['router_ns'], ext_face, iface)

            self.os.execute_command(cmd_iptables_nat, blocking=True, external=True)
            self.os.execute_command(cmd_iptables_forward_in, blocking=True, external=True)
            self.os.execute_command(cmd_iptables_forward_out, blocking=True, external=True)



        else:
            self.logger.error('add_port_to_router()', 'Router port_type is not recognized: {} or vnet_id is None'.format(port_type))
            return {'error': 403}

        self.logger.info('add_port_to_router()', 'Router port added')
        self.routers.update({router_id: record})
        self.connector.loc.actual.add_node_router(self.node, self.uuid, router_id, record)
        return {'result': record}


    def remove_port_from_router(self, router_id, vnet_id):
        self.logger.info('remove_port_from_router()', 'Removing port from router {}'.format(router_id))
        record = self.routers.get(router_id)
        if record is None:
            self.logger.error('remove_port_from_router()','Router {} does not exist'.format(router_id))
            return {'error': 404}

        # Sorting ports to have always the same order
        ports = sorted(record['ports'], key=lambda k: k['port_type']+k['faces'][0])
        record.update({'ports': ports})

        ext_face = ports[0]['faces'][0]

        ports = [x for x in record['ports'] if x.get('pair_id') is not None and x.get('pair_id') == vnet_id]
        if len(ports) == 0:
            self.logger.error('remove_port_from_router()','Router {} is not connected to {}'.format(router_id, vnet_id))
            return {'error': 403}

        for p in ports:
            net_record = self.networks.get(p['pair_id'])
            net_ns = net_record['properties']['net_ns']

            cmd_remove_face = 'sudo ip netns exec {} ip link del {}'.format(net_ns, p['faces'][1])
            self.os.execute_command(cmd_remove_face, blocking=True, external=True)

            cmd_iptables_nat = 'sudo ip netns exec {} iptables -t nat -D POSTROUTING -s {} -o {} -j MASQUERADE'.format(record['router_ns'], p['ip_address'], ext_face)
            cmd_iptables_forward_in = 'sudo ip netns exec {} iptables -D FORWARD -i {} -o {} -j ACCEPT'.format(record['router_ns'], ext_face, p['faces'][0])
            cmd_iptables_forward_out = 'sudo ip netns exec {} iptables -D FORWARD -o {} -i {} -j ACCEPT'.format(record['router_ns'], ext_face, p['faces'][0])

            self.os.execute_command(cmd_iptables_nat, blocking=True, external=True)
            self.os.execute_command(cmd_iptables_forward_in, blocking=True, external=True)
            self.os.execute_command(cmd_iptables_forward_out, blocking=True, external=True)

            self.logger.info('remove_port_from_router()', 'Removed Internal Face {}'.format(p['faces'][0]))

        ports = list(set(record['ports'])-set(ports))
        record.update({'ports': ports})
        self.routers.update({router_id: record})
        self.connector.loc.actual.add_node_router(self.node, self.uuid, router_id, record)
        return {'result': record}


    def create_virtual_network(self, manifest):
        net_uuid = manifest.get('uuid')
        descriptor = self.agent.get_network_info(net_uuid)
        self.logger.info('create_virtual_network()','Creating Network with UUID: {}'.format(net_uuid))
        self.logger.info('create_virtual_network()','Creating Network: {}'.format(manifest))
        net = self.networks.get(net_uuid, None)
        if net is not None:
            self.logger.error(
                'create_virtual_network()', '{} network already exists'.format(net_uuid))
            return None

        n_small_id = net_uuid.split('-')[0]
        vdev_name = 'br-{}'.format(n_small_id)
        netns_name = 'fosns-{}'.format(n_small_id)

        properties = {}
        face = self.overlay_interface
        if 'face' in manifest:
            face = manifest['face']

        vni = self.__get_vni(net_uuid)
        if 'vni' in manifest:
            vni = manifest['vni']

        mcast_addr = self.__get_mcast_addr(net_uuid)
        if 'mcast_addr' in manifest:
            mcast_addr = manifest['mcast_addr']

        vlan_id = self.__get_vlan_id(net_uuid, self.vlan_range[0], self.vlan_range[1])
        if 'vlan_id' in manifest:
            vlan_id = manifest['vlan_id']

        overlay = not self.use_vlan
        if 'overlay' in manifest:
            overlay = manifest['overlay']

        if overlay:
            start_file  = self.__generate_vnet_start_script2(n_small_id, net_uuid, vni, mcast_addr, face)
            shutdown_file = self.__generate_vnet_stop_script2(n_small_id)
            self.os.execute_command(os.path.join(self.BASE_DIR, start_file),blocking=True, external=True)
            properties.update({'vxlan_id': vni})
            properties.update({'mcast_addr': mcast_addr})
        else:
            properties.update({'vlan_id': vlan_id})
            start_file = self.__generate_vnet_vlan_start_script2(n_small_id, net_uuid, vlan_id, face)
            shutdown_file = self.__generate_vnet_vlan_stop_script2(n_small_id)
            self.os.execute_command(os.path.join(self.BASE_DIR, start_file), blocking=True, external=True)
            properties.update({'vlan_id': vlan_id})


        properties.update({'virtual_device': vdev_name})
        properties.update({'net_ns': netns_name})
        properties.update({'manager':self.uuid})

        if manifest.get('ip_configuration') is not None:
            self.logger.info('create_virtual_network()','Networks as address informations: {}'.format(manifest.get('ip_configuration')))
            dhcp_file = self.__generate_dnsmaq_script(manifest)
            self.os.execute_command(os.path.join(self.BASE_DIR, self.DHCP_DIR, dhcp_file),blocking=True, external=True)

        manifest.update({'status':'CREATE'})
        manifest.update({'properties':properties})
        self.networks.update({net_uuid: manifest})
        self.net_files.update({net_uuid: (start_file, shutdown_file)})
        self.connector.loc.actual.add_node_network(self.node, self.uuid, net_uuid, manifest)
        self.logger.info('create_virtual_network()','Created {} Network'.format(net_uuid))



    def allocate_bandwidth(self, intf_uuid, bandwidth):
        raise NotImplementedError

    def assign_interface_to_network(self, network_uuid, intf_uuid):
        pass

    # eval
    def connect_interface_to_connection_point(self, intf_id, cp_id):
        self.logger.info('connect_interface_to_connection_point()','vIntf {} <-> CP {} Network'.format(intf_id, cp_id))
        intf_info = self.intfs.get(intf_id)
        cp_info = self.ports.get(cp_id)
        self.logger.info('connect_interface_to_connection_point()','Face \n{} CP {}'.format(intf_info, cp_info))
        if intf_info is None or cp_info is None:
            self.logger.error('connect_interface_to_connection_point',
            'Nor connection point or virtual interface exist')
            return {'error':-2}
        ext_intf = intf_info.get('ext_name')
        int_cp = cp_info.get('cp_name')
        cmd = 'sudo ip link set dev {} master {}'.format(ext_intf, int_cp)
        self.os.execute_command(cmd,blocking=True, external=False)
        return {'result':{'int':intf_id, 'ext':cp_id}}


    # eval
    def disconnect_interface(self, intf_id):
        intf_info = self.intfs.get(intf_id)
        if intf_info is None:
            self.logger.error('disconnect_interface',
            'Virtual interface does not exist')
            return {'error':-2}
        ext_intf = intf_info.get('ext_name')
        cmd = 'sudo ip link set dev {} nomaster'.format(ext_intf)
        return {'result':{'int':intf_id, 'ext':None}}

    # eval
    def connect_cp_to_vnetwork(self, cp_id, vnet_id):
        self.logger.info('connect_cp_to_vnetwork()','CP {} <-> {} Network'.format(cp_id, vnet_id))
        net_info = self.networks.get(vnet_id)
        cp_info = self.ports.get(cp_id)
        if net_info is None or cp_info is None:
            self.logger.error('connect_cp_to_vnetwork',
            'Nor connection point or virtual network exist')
            return {'error':-2}
        self.logger.info('connect_cp_to_vnetwork()','Net Info {}'.format(net_info))
        net_dev = net_info.get('properties').get('virtual_device')
        ext_cp = cp_info.get('ext_name')
        cmd = 'sudo ip link set dev {} master {}'.format(ext_cp, net_dev)
        self.os.execute_command(cmd, blocking=True, external=False)
        self.logger.info('connect_cp_to_vnetwork()','CP {} <-> vNet {} OK'.format(cp_id, vnet_id))
        return {'result':{'int':cp_id, 'ext':vnet_id}}

    # eval
    def disconnect_cp(self, cp_id):
        self.logger.info('disconnect_cp()','Disconnecting CP {}'.format(cp_id))
        cp_info = self.ports.get(cp_id)
        if cp_info is None:
            self.logger.error('disconnect_interface',
            'Connection point does not exist')
            return {'error':-2}
        self.logger.info('disconnect_cp()','CP info {}'.format(cp_info))
        ext_cp = cp_info.get('ext_name')
        cmd = 'sudo ip link set dev {} nomaster'.format(ext_cp)
        self.os.execute_command(cmd,blocking=True, external=False)
        self.logger.info('disconnect_cp()','Disconnected CP {}'.format(cp_id))
        return {'result':{'int':cp_id, 'ext':None}}



    def remove_interface_from_network(self, network_uuid, intf_uuid):
        pass

    def delete_virtual_network(self, network_uuid):
        self.logger.info('delete_virtual_network()','Deletting {}'.format(network_uuid))
        net = self.networks.get(network_uuid, None)
        if net is None:
            raise BridgeAssociatedToNetworkException(
                '{} network not exists'.format(network_uuid))
        # if len(net.get('interfaces')) > 0:
        #     raise NetworkHasPendingInterfacesException(
        #         '{} has pending interfaces'.format(network_uuid))



        # dnsmasq_file = os.path.join(
        #     self.BASE_DIR, self.DHCP_DIR, 'br-{}_dnsmasq.sh'.format(network_uuid.split('-')[0]))

        if net.get('ip_configuration') is not None:
            n_small_id = network_uuid.split('-')[0]
            path = os.path.join(self.BASE_DIR, self.DHCP_DIR)
            pid_file =  os.path.join(path,'net_{}.pid'.format(n_small_id))
            conf = os.path.join(path,'net_{}.conf'.format(n_small_id))
            lease_file = os.path.join(path,'net_{}_leases'.format(n_small_id))
            start_file = os.path.join(path,'dhcp_{}.sh'.format(n_small_id))
            pid = int(self.os.read_file(pid_file))

            dhcp_intf = 'dhcp-{}-e'.format(n_small_id)
            killcmd = 'sudo kill -9 {}'.format(pid)
            self.os.execute_command(killcmd, blocking=True, external=True)

            self.os.remove_file(conf)
            self.os.remove_file(start_file)
            self.os.remove_file(lease_file)
            cmd = 'sudo ip link del {}'.format(dhcp_intf)
            self.os.execute_command(cmd,blocking=True, external=True)



        start_file, shutdown_file = self.net_files.get(network_uuid)
        shutdown_file = os.path.join(self.BASE_DIR, shutdown_file)
        start_file = os.path.join(self.BASE_DIR, start_file)
        self.os.execute_command('sudo {}'.format(shutdown_file),blocking=True, external=True)
        self.os.remove_file(shutdown_file)
        self.os.remove_file(start_file)
        m  = self.networks.pop(network_uuid)
        m.update({'status':'DESTROY'})
        self.net_files.pop(network_uuid)
        self.connector.loc.actual.add_node_network(self.node, self.uuid, network_uuid, m)
        self.logger.info('delete_virtual_network()','Deleted {}'.format(network_uuid))

        return True

    def stop_network(self):
        keys = list(self.networks.keys())
        for k in keys:
            self.delete_virtual_network(k)
        return True

    def get_network_info(self, network_uuid):
        if network_uuid is None:
            return self.networks
        return self.networks.get(network_uuid)


    # FLOATING IPs #

    def create_floating_ip(self):
        self.logger.info('create_floating_ip()', 'Creating new floating IP')
        ip_id = '{}'.format(uuid.uuid4())
        ip_small_id = ip_id.split('-')[0]
        vface = 'fl-{}'.format(ip_small_id)
        face = self.overlay_interface
        cmd = "sudo ip link add {} link {} type macvlan mode vepa".format(vface, face)
        self.os.execute_command(cmd,blocking=True, external=True)
        cmd = "sudo dhclient {}".format(vface)
        self.os.execute_command(cmd,blocking=False, external=True)
        try:
            addr = netifaces.ifaddresses(vface)[2][0]['addr']
            mask = netifaces.ifaddresses(face)[2][0]['netmask']
            addr = self.__ip_mask2cird(addr, mask)
        except:
            self.logger.error('create_floating_ip()','Unable to retrieve address for floating interface')
            addr = ''
        float_record = {
            'uuid':ip_id,
            'ip_version':'IPV4',
            'address':addr,
            'face':face,
            'vface':vface,
            'cp_id':'',
            'router_id':''
        }
        self.logger.info('create_floating_ip()',' [ DONE ] New floating IP created {}'.format(float_record))
        self.connector.loc.actual.add_node_floating_ip(self.node, self.uuid, ip_id, float_record)
        self.floating_ips.update({ip_id: float_record})
        return {'result':float_record}

    def delete_floating_ip(self, ip_id):
        self.logger.info('delete_floating_ip()', 'Deting floating IP  {}'.format(ip_id))
        ip_small_id = ip_id.split('-')[0]
        vface = 'fl-{}'.format(ip_small_id)
        cmd = 'sudo ip link del {}'.format(vface)
        self.os.execute_command(cmd,blocking=True, external=True)
        rec = self.connector.loc.actual.get_node_floating_ip(self.node, self.uuid, ip_id)
        self.connector.loc.actual.remove_node_floating_ip(self.node, self.uuid, ip_id)
        self.logger.info('delete_floating_ip()', '[DONE] Deletted IP {}'.format(ip_id))
        self.floating_ips.pop(ip_id)
        return {'result': rec}

    def assign_floating_ip(self, ip_id, cp_id):
        self.logger.info('assign_floating_ip()', 'Assigning floating IP {} to {}'.format(ip_id, cp_id))
        rec = self.connector.loc.actual.get_node_floating_ip(self.node, self.uuid, ip_id)
        if rec is None:
            self.logger.error('assign_floating_ip()', 'Not found IP: {}'.format(ip_id))
            return {'error': 404}

        cp_ip = self.__get_cp_ip(cp_id)
        if cp_ip == '':
            self.logger.error('assign_floating_ip()', 'Connection point {} as not IP'.format(ip_id))
            return {'error': 404}

        self.logger.info('assign_floating_ip()', 'Getting CP external connections')
        fitered_routers = []
        elegible_routers = self.__get_cp_routers(cp_id)

        for r in elegible_routers:
            self.logger.info('assign_floating_ip()', 'Applying filter to router: {}'.format(r))
            for p in r['ports']:
                if p['port_type'] == 'EXTERNAL' and self.__ip2cidr(p['ip_address']) == self.__ip2cidr(rec['address']):
                    fitered_routers.append(r)

        if len(fitered_routers) == 0:
            self.logger.error('assign_floating_ip()', 'Connection point unreachable from external networks!')
            return {'error': 404}

        self.logger.info('assign_floating_ip()', 'Filtered routers: {}'.format(len(fitered_routers)))
        router = fitered_routers[0]

        self.logger.error('assign_floating_ip()', 'Moving the virtual interface to router namespace')

        cmd_move_face_to_ns = 'sudo ip link set {} netns {}'.format(rec['vface'], router['router_ns'])
        cmd_dev_up = 'sudo ip netns exec {} ip link set {} up'.format(router['router_ns'], rec['vface'])
        cmd_reassing_ip = 'sudo ip netns exec {} ip addr add {} dev {}'.format(router['router_ns'], rec['address'], rec['vface'])
        cmd = 'sudo ip netns exec {} iptables -t nat -A PREROUTING -d {} -j DNAT --to {}'.format(router['router_ns'], rec['address'].split('/')[0], cp_ip)

        self.os.execute_command(cmd_move_face_to_ns,blocking=True, external=True)
        self.os.execute_command(cmd_dev_up,blocking=True, external=True)
        self.os.execute_command(cmd_reassing_ip,blocking=True, external=True)
        self.os.execute_command(cmd,blocking=True, external=True)

        rec.update({'cp_id':cp_id})
        rec.update({'router_id':router['uuid']})
        self.connector.loc.actual.add_node_floating_ip(self.node, self.uuid, ip_id, rec)
        self.logger.info('assign_floating_ip()', '[DONE] assigned floating IP {} to {}'.format(ip_id, cp_id))
        self.floating_ips.update({ip_id: rec})
        return {'result': rec}



    def remove_floating_ip(self, ip_id, cp_id):
        self.logger.info('remove_floating_ip()', 'Removing floating IP {} from {}'.format(ip_id, cp_id))
        rec = self.connector.loc.actual.get_node_floating_ip(self.node, self.uuid, ip_id)
        if rec is None:
            self.logger.error('remove_floating_ip()', 'Not found IP: {}'.format(ip_id))
            return {'error': 404}
        cp_ip = self.__get_cp_ip(cp_id)
        if cp_ip == '':
            self.logger.error('remove_floating_ip()', 'Connection point {} has no IP'.format(ip_id))
            return {'error': 404}

        router = self.routers[rec['router_id']]

        self.logger.info('assign_floating_ip()', 'Moving the virtual interface to default namespace')

        cmd = 'sudo ip netns exec {} iptables -t nat -D PREROUTING -d {} -j DNAT --to {}'.format(router['router_ns'], rec['address'].split('/')[0], cp_ip)
        cmd_to_default_ns = 'sudo ip netns exec {} ip link set {} netns 1'.format(router['router_ns'],rec['vface'])
        cmd_assign_ip = 'sudo ip addr add {} dev {}'.format(rec['address'], rec['vface'])

        self.os.execute_command(cmd,blocking=True, external=True)
        self.os.execute_command(cmd_to_default_ns,blocking=True, external=True)
        self.os.execute_command(cmd_assign_ip,blocking=True, external=True)

        rec.update({'cp_id':''})
        rec.update({'router_id':''})
        self.connector.loc.actual.add_node_floating_ip(self.node, self.uuid, ip_id, rec)
        self.logger.info('remove_floating_ip()', '[DONE] removed floating IP {} from {}'.format(ip_id, cp_id))
        self.floating_ips.update({ip_id: rec})
        return {'result': rec}

    # ============ #



    # EVAL called by agent for CPs #

    def create_port_from_descriptor(self, descriptor):
        descriptor = json.loads(descriptor)
        try:
            cp_uuid = '{}'.format(uuid.uuid4())
            cp_id = descriptor.get('uuid')
            # descriptor = self.agent.get_port_info(record.get('cp_uuid'))
            cp_small_id = ''.join([x[0] for x in cp_uuid.split('-')])
            cp_name = 'br-cp-{}'.format(cp_small_id)
            int_name = 'cp-{}-i'.format(cp_small_id)
            ext_name = 'cp-{}-e'.format(cp_small_id)
            self.logger.info('create_port', 'Creating {} {} {}'.format(cp_name, int_name, ext_name))
            start_file = self.__generate_port_create_script(int_name, ext_name, cp_name)
            stop_file = self.__generate_port_destroy_script(ext_name, cp_name)
            cmd_start = os.path.join(self.BASE_DIR, start_file)
            cmd_stop = os.path.join(self.BASE_DIR, stop_file)
            self.os.execute_command(cmd_start,blocking=True, external=True)
            cp_info = {
                'descriptor':descriptor,
                'int_name': int_name,
                'ext_name':ext_name,
                'cp_name':cp_name,
                'start':cmd_start,
                'stop':cmd_stop
            }
            self.ports.update({cp_uuid: cp_info})
            # if descriptor.get("vld_ref") is not None:
            #     pair_id = descriptor.get("vld_ref")
            #     self.connect_cp_to_vnetwork(cp_id, pair_id)
            properties = {
                'int_name': int_name,
                'ext_name':ext_name,
                'cp_name':cp_name,
                'start':cmd_start,
                'stop':cmd_stop
            }

            record = {
                'uuid':cp_uuid,
                'cp_id':cp_id,
                'cp_type':descriptor.get('cp_type'),
                'vld_ref':descriptor.get('vld_ref'),
                'port_secutiry_enabled':descriptor.get('port_security_enabled'),
                'veth_face_name':ext_name,
                'br_name':properties['cp_name'],
                'properties':properties,
                'status':'CREATE'
            }
            self.connector.loc.actual.add_node_port(self.node, self.uuid, cp_uuid,record)
            return {'result':record}
        except Exception as e:
            import traceback
            self.logger.error('create_port_from_descriptor()', '[ERROR] {}'.format(traceback.format_exc()))
            traceback.format_exc()
            self.logger.error('create_port_from_descriptor()', '[ERROR] got error {}'.format(e))
            return {'error':503, 'error_msg':'{}'.format(e)}


    def destroy_port_agent(self, cp_id):
        port_info = self.ports.get(cp_id)
        if port_info is None:
            self.logger.error('delete_port','{} does not exist'.format(cp_id))
            return False
        stop_file = port_info.get('stop')
        self.os.execute_command(stop_file,blocking=True, external=True)
        self.os.remove_file(stop_file)
        self.os.remove_file(port_info.get('start'))
        self.ports.pop(cp_id)
        rec = self.connector.loc.actual.get_node_port(self.node, self.uuid, cp_id)
        rec.update({'STATUS':'DESTROY'})
        self.connector.loc.actual.remove_node_port(self.node, self.uuid, cp_id)
        return {'result':rec}

        # ================================= #

    def __get_cp_ip(self, cp_id):
        cp_rec = self.connector.loc.actual.get_node_port(self.node, self.uuid, cp_id)
        self.logger.info('__get_cp_ip()', 'Get connection point IP for {} Record: {}'.format(cp_id, cp_rec))
        fdus = self.connector.loc.actual.get_node_all_fdus_instances(self.node)
        cp_ip = ''
        self.logger.info('__get_cp_ip()', 'Scanning FDUs')
        for i in fdus:
            intfs = i['interfaces']
            for intf in intfs:
                if intf.get('cp_id') is not None and intf.get('cp_id') != '':
                    if intf.get('cp_id') == cp_rec['uuid']:
                        i_name = intf['vintf_name']
                        hv_info = i['hypervisor_info']
                        if len(hv_info) > 0:
                            cp_ip = hv_info['network'][i_name]['addresses'][0]['address']
        self.logger.info('__get_cp_ip()', 'IP for {} -> {}'.format(cp_id, cp_ip))
        return cp_ip

    def __get_cp_routers(self, cp_id):
        cp_rec = self.connector.loc.actual.get_node_port(self.node, self.uuid, cp_id)
        self.logger.info('__get_cp_routers()', 'Get connection point IP for {} Record: {}'.format(cp_id, cp_rec))
        fdus = self.connector.loc.actual.get_node_all_fdus_instances(self.node)

        elegible_routers = []

        fdu_id = ''
        self.logger.info('__get_cp_routers()', 'Scanning FDUs')
        for i in fdus:
            intfs = i['interfaces']
            for intf in intfs:
                if intf.get('cp_id') is not None and intf.get('cp_id') != '':
                    if intf.get('cp_id') == cp_rec['uuid']:
                        fdu_id = i['fdu_uuid']
        if fdu_id is '':
            return elegible_routers

        fdud =  self.agent.get_fdu_info(fdu_id)
        netid = ''
        self.logger.info('__get_cp_routers()', 'Scanning FDU Interfaces')
        for c in fdud['connection_points']:
            if c['uuid'] == cp_rec['cp_uuid']:
                netid = c['vld_ref']

        self.logger.info('__get_cp_routers()', 'CP is connected to {}'.format(netid))
        if netid is '':
            return elegible_routers


        for r in self.routers:
            router = self.routers[r]
            for p in router['ports']:
                if p['port_type'] == 'INTERNAL' and p.get('pair_id','') == netid:
                    elegible_routers.append(router)

        self.logger.info('__get_cp_routers()', 'Got {} elegible routers'.format(len(elegible_routers)))
        return elegible_routers

    def __cird2block(self, cird):
        '''
            Convert cird subnet to first address (for router), first dhcp, last dhcp, netmask

        :param cird:
        :return:
        '''
        (ip, cidr) = cird.split('/')
        cidr = int(cidr)
        host_bits = 32 - cidr
        netmask = socket.inet_ntoa(struct.pack(
            '!I', (1 << 32) - (1 << host_bits)))
        i = struct.unpack('>I', socket.inet_aton(ip))[0]
        start = (i >> host_bits) << host_bits
        end = i | ((1 << host_bits) - 1)

        return socket.inet_ntoa(struct.pack('>I', start + 1)), socket.inet_ntoa(
            struct.pack('>I', start + 2)), socket.inet_ntoa(struct.pack('>I', end - 1)), netmask


    def __ip2cidr(self, ip):
        (ip, cidr) = ip.split('/')
        cidr = int(cidr)
        host_bits = 32 - cidr
        i = struct.unpack('>I', socket.inet_aton(ip))[0]
        start = (i >> host_bits) << host_bits
        return socket.inet_ntoa(struct.pack('>I', start))+'/'+str(cidr)


    def __get_net_size(self, netmask):
        binary_str = ''
        for octet in netmask:
            binary_str += bin(int(octet))[2:].zfill(8)
        return str(len(binary_str.rstrip('0')))

    def __ip_mask_to_cird(self, ip, mask):

        try:
            socket.inet_aton(ip)
            socket.inet_aton(mask)
        except:
            return "0.0.0.0/0"

        ip = ip.split('.')
        mask = mask.split('.')
        net_start = [str(int(ip[x]) & int(mask[x])) for x in range(0, 4)]
        return '.'.join(net_start) + '/' + self.__get_net_size(mask)


    def __ip_mask2cird(self,ip, mask):

        try:
            socket.inet_aton(ip)
            socket.inet_aton(mask)
        except:
            return "0.0.0.0/0"

        ip = ip.split('.')
        mask = mask.split('.')
        net_start = [str(int(ip[x])) for x in range(0, 4)]
        return '.'.join(net_start) + '/' + self.__get_net_size(mask)


    def __net_observer(self, net_info):
        self.logger.info('__net_observer()', 'Linux Bridge Plugin - New Action of a Network - Net Info: {}'.format(net_info))
        action = net_info.get('status')
        net_uuid = net_info.get('uuid')
        if action == 'DESTROY':
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - This is a remove for : {}'.format(net_info))
            self.delete_virtual_network(net_uuid)
        elif action == 'CREATE':
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - This is a add for : {}'.format(net_info))
            self.create_virtual_network(net_info)
        else:
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - Action not recognized : {}'.format(action))


    def __port_observer(self, port_info):
        self.logger.info('__port_observer()', 'Linux Bridge Plugin - New Action of a Port - Port Info: {}'.format(port_info))
        action = port_info.get('status')
        port_uuid = port_info.get('uuid')
        if action == 'DESTROY':
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - This is a remove for : {}'.format(port_info))
            self.delete_port(port_uuid)
        elif action == 'CREATE':
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - This is a add for : {}'.format(port_info))
            self.create_port(port_info)
        else:
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - Action not recognized : {}'.format(action))


    def __router_observer(self, router_info):
        self.logger.info('__router_observer()', 'Linux Bridge Plugin - New Action of a Router - Router Info: {}'.format(router_info))
        action = router_info.get('state')
        router_uuid = router_info.get('uuid')
        if action == 'DESTROY':
            self.logger.info('__router_observer()', 'Linux Bridge Plugin - This is a remove for : {}'.format(router_info))
            self.delete_router(router_uuid)
        elif action == 'CREATE':
            self.logger.info('__router_observer()', 'Linux Bridge Plugin - This is a add for : {}'.format(router_info))
            self.create_router(router_info)
        else:
            self.logger.info('__router_observer()', 'Linux Bridge Plugin - Action not recognized : {}'.format(action))


    def __generate_interface_create_script(self, internal_name, external_name, name):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vface_creation.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(int_port=internal_name, ext_port=external_name)
        f_name = 'create_face_{}.sh'.format(name)
        self.os.store_file(net_sh, self.BASE_DIR, f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd,blocking=True, external=False)
        return f_name

    def __generate_interface_destroy_script(self, external_name, name):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vface_destroy.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(ext_port=external_name)

        f_name = 'destroy_face_{}.sh'.format(name)
        self.os.store_file(net_sh, self.BASE_DIR, f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd, blocking=True, external=False)
        return f_name


    def __generate_port_create_script(self, internal_name, external_name, name):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'cp_creation.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(int_port=internal_name, ext_port=external_name, cp_name=name)

        f_name = 'create_port_{}.sh'.format(name)
        self.os.store_file(net_sh, self.BASE_DIR,f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd,blocking=True,external=False)
        return f_name

    def __generate_port_destroy_script(self, external_name, name):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'cp_destroy.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(ext_port=external_name, cp_name=name)

        f_name = 'destroy_port_{}.sh'.format(name)
        self.os.store_file(net_sh, self.BASE_DIR,f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd,blocking=True, external=False)
        return f_name
# ########################## NEW SCRIPT CREATION FUNCTIONS:
    def __generate_vnet_start_script2(self, netid, net_uuid, vxlan_id, mcast_addr, overlay_interface):

        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vnet_create.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid, group_id=vxlan_id, mcast_group_address=mcast_addr, wan=overlay_interface)

        f_name = 'start_{}.sh'.format(netid)
        self.os.store_file(net_sh, self.BASE_DIR, f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd,blocking=True, external=False)
        return f_name

    def __generate_vnet_stop_script2(self, netid):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vnet_destroy.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)

        f_name = 'stop_{}.sh'.format(netid)
        self.os.store_file(net_sh, self.BASE_DIR, f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd,blocking=True, external=False)
        return f_name

    def __generate_vnet_vlan_start_script2(self, netid, net_uuid, vlan_id, vlan_face):

        vintf = '{}.{}'.format(vlan_face, vlan_id)
        if not self.check_if_interface_exists(vintf):
            self.create_vlan_interface(vlan_face, vlan_id)

        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vnet_create_vlan.sh'))
        net_sh = Environment().from_string(template_sh)

        net_sh = net_sh.render(net_id=netid, vlan_intf=vintf)

        f_name = 'start_{}.sh'.format(netid)
        self.os.store_file(net_sh, self.BASE_DIR,f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd,blocking=True, external=False)
        return f_name

    def __generate_vnet_vlan_stop_script2(self, netid):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vnet_destroy_vlan.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)

        f_name = 'stop_{}.sh'.format(netid)
        self.os.store_file(net_sh, self.BASE_DIR, f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd, blocking=True, external=False)
        return f_name




# ###########################
    def __generate_vnet_start_script(self, netid, net_uuid):

        vxlan_id = self.__get_vni(net_uuid)
        mcast_addr = self.__get_mcast_addr(net_uuid)

        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vnet_create.sh'))
        net_sh = Environment().from_string(template_sh)
        overlay_interface = self.overlay_interface
        net_sh = net_sh.render(net_id=netid, group_id=vxlan_id, mcast_group_address=mcast_addr, wan=overlay_interface)

        f_name = 'start_{}.sh'.format(netid)
        self.os.store_file(net_sh, self.BASE_DIR, f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd,blocking=True, external=False)
        return f_name

    def __generate_vnet_stop_script(self, netid):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vnet_destroy.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)

        f_name = 'stop_{}.sh'.format(netid)
        self.os.store_file(net_sh, self.BASE_DIR, f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd, blocking=True, external=False)
        return f_name

    def __generate_vnet_vlan_start_script(self, netid, net_uuid):

        vlan_id = self.__get_vlan_id(net_uuid, self.vlan_range[0], self.vlan_range[1])
        mcast_addr = self.__get_mcast_addr(net_uuid)
        vintf = '{}.{}'.format(self.vlan_face, vlan_id)
        if not self.check_if_interface_exists(vintf):
            self.create_vlan_interface(self.vlan_face, vlan_id)

        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vnet_create_vlan.sh'))
        net_sh = Environment().from_string(template_sh)

        net_sh = net_sh.render(net_id=netid, vlan_intf=vintf)

        f_name = 'start_{}.sh'.format(netid)
        self.os.store_file(net_sh, self.BASE_DIR, f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd, blocking=True, external=False)
        return f_name

    def __generate_vnet_vlan_stop_script(self, netid):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vnet_destroy_vlan.sh'))
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)

        f_name = 'stop_{}.sh'.format(netid)
        self.os.store_file(net_sh, self.BASE_DIR,f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd,blocking=True, external=False)
        return f_name


    def __generate_dnsmaq_script(self, descriptor):
        net_uuid = descriptor.get('uuid')
        address_info = descriptor.get('ip_configuration')
        n_small_id = net_uuid.split('-')[0]
        vdev_name = 'br-{}'.format(n_small_id)
        netns_name = 'fosns-{}'.format(n_small_id)
        path = os.path.join(self.BASE_DIR, self.DHCP_DIR)

        template_conf = self.os.read_file(os.path.join(self.DIR, 'templates', 'dnsmasq.conf'))

        dhcp_intf = 'dhcp-{}-i'.format(n_small_id)
        lease_file = os.path.join(path,'net_{}_leases'.format(n_small_id))
        pid_file =  os.path.join(path,'net_{}.pid'.format(n_small_id))
        conf = 'net_{}.conf'.format(n_small_id)
        start_file = 'dhcp_{}.sh'.format(n_small_id)
        addrs = self.__cird2block(address_info.get('subnet'))


        dnsmasq_conf = Environment().from_string(template_conf)
        dnsmasq_conf = dnsmasq_conf.render(dhcpinterface=dhcp_intf, lease_file=lease_file,dhcppid=pid_file)
        if address_info.get('dhcp_range') is not None and address_info.get('dhcp_enable') :
            dnsmasq_conf = dnsmasq_conf+'\ndhcp-range={},86400s'.format(address_info.get('dhcp_range'))
        else:
            #dnsmasq_conf = dnsmasq_conf+'\ndhcp-range={},static,86400s'.format(address_info.get('subnet').split('/')[0])
            dnsmasq_conf = dnsmasq_conf+'\ndhcp-range={},{},86400s'.format(addrs[1], addrs[2])
        if address_info.get('gateway') is not None:
            dnsmasq_conf = dnsmasq_conf+'\ndhcp-option=3,{}'.format(address_info.get('gateway'))
        if address_info.get('dns') is not None:
            dnsmasq_conf = dnsmasq_conf+'\ndhcp-option=6,{}'.format(address_info.get('dns'))

        self.os.store_file(dnsmasq_conf, path, conf)

        template_start = self.os.read_file(os.path.join(self.DIR, 'templates', 'dnsmasq.sh'))
        dnsmasq_sh = Environment().from_string(template_start)

        dns_face_ip = address_info.get('subnet').split('/')[0]
        dnsmasq_sh = dnsmasq_sh.render(netid=n_small_id, dhcp_conf_path=os.path.join(path, conf), ip=dns_face_ip, mask=addrs[-1])
        self.os.store_file(dnsmasq_sh, path, start_file)

        chmod_cmd = 'chmod +x {}'.format(os.path.join(path, start_file))
        self.os.execute_command(chmod_cmd,blocking=True, external=False)
        return start_file

    def __generate_vxlan_shutdown_script(self, net_uuid):
        template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vxlan_destroy.sh'))
        br_name = 'br-{}'.format(net_uuid.split('-')[0])
        vxlan_name = 'vxl-{}'.format(net_uuid.split('-')[0])
        file_name = '{}_dnsmasq.pid'.format(br_name)
        pid_file_path = os.path.join(self.BASE_DIR, self.DHCP_DIR, file_name)
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(
            bridge=br_name, vxlan_intf_name=vxlan_name, dnsmasq_pid_file=pid_file_path)

        self.logger.info('__generate_port_create_script()', 'File content : {}'.format(net_sh))
        file_name = '{}_stop.sh'.format(br_name)
        self.os.store_file(net_sh, self.BASE_DIR, file_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, file_name))
        self.os.execute_command(chmod_cmd, blocking=True, external=False)

        return file_name


    def __generate_vxlan_script(self, net_uuid, manifest=None):
        if not self.overlay_interface:
            template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vxlan_creation.sh'))
        else:
            template_sh = self.os.read_file(os.path.join(self.DIR, 'templates', 'vxlan_creation_intf.sh'))
        net_sh = Environment().from_string(template_sh)
        br_name = 'br-{}'.format(net_uuid.split('-')[0])
        vxlan_name = 'vxl-{}'.format(net_uuid.split('-')[0])

        if manifest is not None:
            if manifest.get('overlay_info') is not None and manifest.get('overlay_info').get('vxlan_id') is not None:
                vxlan_id = manifest.get('overlay_info').get('vxlan_id')
            else:
                vxlan_id = len(self.networks) + 1
            if manifest.get('overlay_info') is not None and manifest.get('overlay_info').get('multicast_address') is not None:
                mcast_addr = manifest.get(
                    'overlay_info').get('multicast_address')
            else:
                mcast_addr = '239.0.0.{}'.format(vxlan_id)
        else:
            vxlan_id = len(self.networks) + 1
            mcast_addr = '239.0.0.{}'.format(vxlan_id)

        net_sh = net_sh.render(bridge_name=br_name, vxlan_intf_name=vxlan_name,
                               group_id=vxlan_id, mcast_group_address=mcast_addr, wan=self.overlay_interface)


        f_name = '{}.sh'.format(net_uuid.split('-')[0])
        self.os.store_file(net_sh, self.BASE_DIR,f_name)
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.os.execute_command(chmod_cmd, blocking=True, external=False)
        return f_name, vxlan_name, vxlan_id, mcast_addr

    def __get_mcast_addr(self, net_id):
        hashdata = hashlib.sha512(net_id.encode('utf8')).digest()
        return '239.245.{}.{}'.format(hashdata[0],hashdata[-1])

    def __get_vni(self, net_id):
        hashdata = hashlib.sha512(net_id.encode('utf8')).digest()
        vni = 0
        for x in hashdata:
            vni += x
        return vni % VNI_LIMIT

    def __get_vlan_id(self, net_id, min_id=0, max_id=VLAN_LIMIT):
        hashdata = hashlib.sha512(net_id.encode('utf8')).digest()
        vlid = 0
        for x in hashdata:
            vlid += x
        vlanid = (vlid % max_id) + min_id
        self.logger.info('__get_vlan_id()', 'Range : {} - {} ID: {}'.format(min_id, max_id, vlanid))
        return vlanid


def read_file(file_path):
    data = ''
    with open(file_path, 'r') as f:
        data = f.read()
    return data


if __name__ == '__main__':
    if len(sys.argv) < 2:
        exit(-1)
    print('ARGS {}'.format(sys.argv))
    file_dir = os.path.dirname(__file__)
    manifest = json.loads(read_file(sys.argv[1]))
    nm = LinuxBridge(manifest.get('name'), manifest.get('version'), manifest.get(
        'uuid'), manifest)
    nm.start_network_manager()
