#!/usr/bin/env python3

# Copyright (c) 2014,2018 ADLINK Technology Inc.
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
# which is available at https://www.apache.org/licenses/LICENSE-2.0.
#
# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
#
# Contributors: Gabriele Baldoni, ADLINK Technology Inc. - Base plugins set


#
# This plugin use Full LinuxBridge implementation for
# connection points and virtual links
#

import sys
import os
import uuid
import struct
import json
import socket
import signal
import base64
import binascii
from jinja2 import Environment
from fog05.interfaces.NetworkPlugin import *
from fog05 import Yaks_Connector
from mvar import MVar
from fog05.DLogger import DLogger


class LinuxBridge(NetworkPlugin):

    def __init__(self, name, version, plugin_uuid, manifest):

        super(LinuxBridge, self).__init__(version, plugin_uuid)
        self.name = name
        loc = manifest.get('configuration').get('ylocator').split('/')[1]
        self.connector = Yaks_Connector(loc)
        self.logger = DLogger(debug_flag=True)
        self.node = manifest.get('configuration').get('nodeid')
        self.manifest = manifest
        self.configuration = manifest.get('configuration', {})
        self.pid = os.getpid()
        self.var = MVar()
        self.agent_conf = \
            self.connector.loc.actual.get_node_configuration(self.node)
        self.logger.info('__init__()', ' Hello from Linux Bridge Plugin')

        self.BASE_DIR = os.path.join(
            self.agent_conf.get('agent').get('path'), 'linuxbridge')

        self.DHCP_DIR = 'dhcp'
        self.HOME = 'network/{}'.format(self.uuid)
        file_dir = os.path.dirname(__file__)
        self.DIR = os.path.abspath(file_dir)
        self.overlay_interface = manifest.get('configuration').get('dataplane_interface')
        if self.overlay_interface is None:
            self.agent_conf.get('agent').get('mgmt_interface')
        self.networks = {}
        self.net_files = {}
        self.intfs = {}
        self.ports = {}
        self.bridges = {}

        signal.signal(signal.SIGINT, self.__catch_signal)
        signal.signal(signal.SIGTERM, self.__catch_signal)

    def __catch_signal(self, signal, _):
        if signal in [2, 15]:
            self.var.put(signal)

    def start_network_manager(self):
        self.logger.info(
            'start_runtime()', 'Linux Bridge Plugin - Starting...')

        if self.call_os_plugin_function('dir_exists', {'dir_path': self.BASE_DIR}):
            if not self.call_os_plugin_function('dir_exists', {'dir_path': os.path.join(self.BASE_DIR, self.DHCP_DIR)}):
                self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.DHCP_DIR)})
        else:
            self.call_os_plugin_function(
                'create_dir', {'dir_path': os.path.join(self.BASE_DIR)})
            self.call_os_plugin_function(
                'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.DHCP_DIR)})

        if self.configuration.get('data_subnet'):
            cird = self.configuration.get('data_subnet')

            data = self.connector.loc.actual.get_node_info(self.node)
            for n in data.get('network'):
                intf_cird = self.__ip_mask_to_cird(
                    n.get('inft_configuration').get('ipv4_address'),
                    n.get('inft_configuration').get('ipv4_netmask')
                )
                if cird == intf_cird:
                    self.overlay_interface = n.get('intf_name')

        d = {
            'create_virtual_interface': self.create_virtual_interface,
            'delete_virtual_interface': self.delete_virtual_interface,
            'create_virtual_bridge': self.create_virtual_bridge,
            'delete_virtual_bridge': self.delete_virtual_bridge,
            'create_bridges_if_not_exist': self.create_bridges_if_not_exist,
            'connect_interface_to_connection_point': self.connect_interface_to_connection_point,
            'disconnect_interface': self.disconnect_interface,
            'connect_cp_to_vnetwork': self.connect_cp_to_vnetwork,
            'disconnect_cp': self.disconnect_cp
        }

        for k in d:
            f = d.get(k)
            self.logger.info(
                '__init__()', 'Linux Bridge Plugin - Registering {}'.format(k))
            self.connector.loc.actual.add_nw_eval(self.node, self.uuid, k, f)

        self.connector.loc.desired.observe_node_networks(
            self.node, self.uuid, self.__net_observer)
        self.connector.loc.desired.observe_node_ports(
            self.node, self.uuid, self.__port_observer)
        self.manifest.update({'pid': self.pid})
        self.manifest.update({'status': 'running'})
        self.connector.loc.actual.add_node_plugin(
            self.node, self.uuid, self.manifest)

        self.logger.info('start_runtime()', 'Linux Bridge Plugin - Data Plane (VxLAN) Interface {}'.format(self.overlay_interface))
        self.logger.info('start_runtime()', 'Linux Bridge Plugin - Started...')

        r = self.var.get()
        self.stop_network_manager()
        self.connector.close()
        exit(0)

    def stop_network_manager(self):
        for k in list(self.intfs.keys()):
            self.delete_virtual_interface(k)
        for k in list(self.ports.keys()):
            self.delete_port(k)
        for k in list(self.networks.keys()):
            self.delete_virtual_network(k)
        for k in list(self.bridges.keys()):
            self.delete_virtual_bridge(k)



    # todo: last item is empty-> delete
    def get_bridge_names_from_output_string(self, output):
        rows = output.split('\n')
        table = [row.split('\t') for row in rows]
        bridges_names = [item[0] for item in table]
        return bridges_names[1:]  # pop name of the table

    def get_virtual_bridges_in_node(self):
        cmd = 'sudo brctl show'
        output = self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        return self.get_bridge_names_from_output_string(output)

    # this is an eval
    def create_bridges_if_not_exist(self, expected_bridges):
        expected_bridges = json.loads(expected_bridges)
        current_bridges = self.get_virtual_bridges_in_node()
        for bridge in expected_bridges:
            if bridge not in current_bridges:
                self.create_virtual_bridge(bridge, '{}'.format(uuid.uuid4()))
        return {'result':expected_bridges}

    # this is an eval
    def create_virtual_interface(self,intf_id, descriptor):
        self.logger.info('create_virtual_interface','Creating {}'.format(intf_id))
        descriptor = json.loads(descriptor)
        intf_name = intf_id
        internal_name = '{}-i'.format(intf_id)
        external_name = '{}-e'.format(intf_id)
        start_file = self.__generate_interface_create_script(internal_name, external_name, intf_name)
        stop_file = self.__generate_interface_destroy_script(external_name, intf_name)
        cmd_start = os.path.join(self.BASE_DIR, start_file)
        cmd_stop = os.path.join(self.BASE_DIR, stop_file)
        self.call_os_plugin_function('execute_command',{'command':cmd_start,'blocking':True, 'external':True})
        descriptor.update({'intf_id':intf_id})
        self.logger.info('create_virtual_interface','Created {}'.format(intf_id))


        intf_info = {
            'descriptor':descriptor,
            'int_name': internal_name,
            'ext_name':external_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        self.intfs.update({intf_id: intf_info})
        if descriptor.get('cp_id') is not None:
            cpid = descriptor.get('cp_id')
            self.logger.info('create_virtual_interface','Attach to {}'.format(cpid))
            self.connect_interface_to_connection_point(intf_id, cpid)
            self.logger.info('create_virtual_interface','Attached to {}'.format(cpid))
        return {'result':intf_info}

    # this is an eval
    def delete_virtual_interface(self, intf_id):
        intf_info = self.intfs.get(intf_id)
        if intf_info is None:
            self.logger.error('delete_virtual_interface','{} does not exist'.format(intf_id))
            return False
        stop_file = intf_info.get('stop')
        if intf_info.get('descriptor').get('cp_id') is not None:
            cpid = intf_info.get('descriptor').get('cp_id')
            self.disconnect_interface(intf_id)
        self.call_os_plugin_function('execute_command',{'command':stop_file,'blocking':True, 'external':True})
        self.call_os_plugin_function('remove_file',{'file_path':stop_file})
        self.call_os_plugin_function('remove_file',{'file_path':intf_info.get('start')})
        self.intfs.pop(intf_id)
        return {'result':intf_id}

    # this is an eval
    def create_virtual_bridge(self, name, uuid):
        cmd = 'sudo ip link add {} type bridge'.format(name)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        br_uuid = uuid
        self.bridges.update({br_uuid: name})
        return {'result':{'uuid':br_uuid, 'name':name}}


    # this is an eval
    def delete_virtual_bridge(self, br_uuid):
        self.logger.info('delete_virtual_bridge', 'Removing {}'.format(br_uuid))
        name = self.bridges.get(br_uuid)
        if name is None:
            self.logger.error('delete_virtual_bridge', 'Bridge {} not existing'.format(br_uuid))
            return {'error':-2}
        cmd = 'sudo ip link del {}'.format(name)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        self.bridges.pop(br_uuid)
        self.logger.info('delete_virtual_bridge', 'Removed {}'.format(br_uuid))
        return {'result':br_uuid}

    def create_port(self, record):
        cp_id = record.get('cp_uuid')
        descriptor = self.get_port_descriptor(cp_id)
        cp_small_id = ''.join([x[0] for x in cp_id.split('-')])
        cp_name = 'br-cp-{}'.format(cp_small_id)
        int_name = 'cp-{}-i'.format(cp_small_id)
        ext_name = 'cp-{}-e'.format(cp_small_id)
        self.logger.info('create_port', 'Creating {} {} {}'.format(cp_name, int_name, ext_name))
        start_file = self.__generate_port_create_script(int_name, ext_name, cp_name)
        stop_file = self.__generate_port_destroy_script(ext_name, cp_name)
        cmd_start = os.path.join(self.BASE_DIR, start_file)
        cmd_stop = os.path.join(self.BASE_DIR, stop_file)
        self.call_os_plugin_function('execute_command',{'command':cmd_start,'blocking':True, 'external':True})
        cp_info = {
            'descriptor':record,
            'int_name': int_name,
            'ext_name':ext_name,
            'cp_name':cp_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        self.ports.update({cp_id: cp_info})
        if descriptor.get("pair_id") is not None:
            pair_id = descriptor.get("pair_id")
            self.connect_cp_to_vnetwork(cp_id, pair_id)
        properties = {
            'int_name': int_name,
            'ext_name':ext_name,
            'cp_name':cp_name,
            'start':cmd_start,
            'stop':cmd_stop
        }
        record.update({'status':'CREATE'})
        record.update({'properties':properties})
        self.connector.loc.actual.add_node_port(self.node, self.uuid, cp_id,record)


    def delete_port(self, cp_id):
        port_info = self.ports.get(cp_id)
        if port_info is None:
            self.logger.error('delete_port','{} does not exist'.format(cp_id))
            return False
        stop_file = port_info.get('stop')
        if port_info.get('descriptor').get('pair_id') is not None:
            pair_id = port_info.get('descriptor').get('pair_id')
            self.disconnect_cp(cp_id)
        self.call_os_plugin_function('execute_command',{'command':stop_file,'blocking':True, 'external':True})
        self.call_os_plugin_function('remove_file',{'file_path':stop_file})
        self.call_os_plugin_function('remove_file',{'file_path':port_info.get('start')})
        self.ports.pop(cp_id)
        self.connector.loc.actual.remove_node_port(self.node, self.uuid, cp_id)



    # network_name, net_uuid, ip_range=None, has_dhcp=False, gateway=None,
    def create_virtual_network(self, manifest):
        net_uuid = manifest.get('uuid')
        descriptor = self.get_network_descriptor(net_uuid)
        self.logger.info('create_virtual_network()','Creating Network with UUID: {}'.format(net_uuid))

        net = self.networks.get(net_uuid, None)
        if net is not None:
            self.logger.error(
                'create_virtual_network()', '{} network already exists'.format(net_uuid))
            return None

        n_small_id = net_uuid.split('-')[0]
        start_file  = self.__generate_vnet_start_script(n_small_id)
        shutdown_file = self.__generate_vnet_stop_script(n_small_id)
        vdev_name = 'br-{}'.format(n_small_id)
        netns_name = 'fosns-{}'.format(n_small_id)

        hx = bytes.fromhex(netid)
        vals = struct.unpack('<{}B'.format(len(hx)), hx)
        vxlan_id = sum(vals)
        mcast_addr = '239.245.{}.{}'.format(vals[0], vals[1])

        self.call_os_plugin_function('execute_command',{'command':os.path.join(self.BASE_DIR, start_file),'blocking':True, 'external':True})
        properties = {}
        properties.update({'virtual_device': vdev_name})
        properties.update({'net_ns': netns_name})
        properties.update({'vxlan_id': vxlan_id})
        properties.update({'mcast_addr': mcast_addr})
        properties.update({'manager':self.uuid})


        # self.agent.getOSPlugin().executeCommand(brcmd)

        # if manifest.get('has_dhcp', False) is True:
        #     address = self.__cird2block(manifest.get('ip_range'))

        #     ifcmd = 'sudo ifconfig {} {} netmask {}'.format(
        #         br_name, address[0], address[3])
        #     # TODO this should done by the OSPlugin
        #     # dhcpq_cmd = 'sudo dnsmasq -d  --interface={} --bind-interfaces  --dhcp-range={},'
        #     #                '{} --listen-address {} > {}/{}/{}.out 2>&1 & echo $! > {}/{}/{}.pid' %
        #     #                (br_name, address[1], address[2], address[0], self.BASE_DIR, self.DHCP_DIR, br_name,
        #     #                 self.BASE_DIR,
        #     #                 self.DHCP_DIR, br_name))
        #     file_name = '{}_dnsmasq.pid'.format(br_name)
        #     pid_file_path = os.path.join(
        #         self.BASE_DIR, self.DHCP_DIR, file_name)

        #     dhcp_cmd = self.__generate_dnsmaq_script(
        #         br_name, address[1], address[2], address[0], pid_file_path)
        #     dhcp_cmd = os.path.join(self.BASE_DIR, self.DHCP_DIR, dhcp_cmd)

        #     self.call_os_plugin_function('execute_command',{'command':ifcmd,'blocking':True, 'external':True})
        #     self.call_os_plugin_function('execute_command',{'command':dhcp_cmd,'blocking':True, 'external':True})

        manifest.update({'status':'CREATE'})
        manifest.update({'properties':properties})
        self.networks.update({net_uuid: manifest})
        self.net_files.update({net_uuid: (start_file, shutdown_file)})
        self.connector.loc.actual.add_node_network(self.node, self.uuid, net_uuid, manifest)
        self.logger.info('create_virtual_network()','Created {} Network'.format(net_uuid))



    def allocate_bandwidth(self, intf_uuid, bandwidth):
        raise NotImplementedError

    def assign_interface_to_network(self, network_uuid, intf_uuid):
        # brctl addif virbr0 vnet0
        # intf = self.interfaces_map.get(intf_uuid, None)
        # if intf is None:
        #     raise InterfaceNotExistingException(
        #         '{} interface not exists'.format(intf_uuid))
        # net = self.networks.get(network_uuid, None)
        # if net is None:
        #     raise BridgeAssociatedToNetworkException(
        #         '{} network not exists'.format(network_uuid))

        # br_cmd = 'sudo brctl addif {}-net {}'.format(
        #     net.get('network_name'), intf)
        # self.agent.get_os_plugin().execute_command(br_cmd)

        # return True
        pass

    # eval
    def connect_interface_to_connection_point(self, intf_id, cp_id):
        self.logger.info('connect_interface_to_connection_point()','vIntf {} <-> CP {} Network'.format(intf_id, cp_id))
        intf_info = self.intfs.get(intf_id)
        cp_info = self.ports.get(cp_id)
        self.logger.info('connect_interface_to_connection_point()','Face \n{} CP {}'.format(intf_info, cp_info))
        if intf_info is None or cp_info is None:
            self.logger.error('connect_interface_to_connection_point',
            'Nor connection point or virtual interface exist')
            return {'error':-2}
        ext_intf = intf_info.get('ext_name')
        int_cp = cp_info.get('cp_name')
        cmd = 'sudo ip link set dev {} master {}'.format(ext_intf, int_cp)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        return {'result':{'int':intf_id, 'ext':cp_id}}


    # eval
    def disconnect_interface(self, intf_id):
        intf_info = self.intfs.get(intf_id)
        if intf_info is None:
            self.logger.error('disconnect_interface',
            'Virtual interface does not exist')
            return {'error':-2}
        ext_intf = intf_info.get('ext_name')
        cmd = 'sudo ip link set dev {} nomaster'.format(ext_intf)
        return {'result':{'int':intf_id, 'ext':None}}

    # eval
    def connect_cp_to_vnetwork(self, cp_id, vnet_id):
        net_info = self.networks.get(vnet_id)
        cp_info = self.ports.get(cp_id)
        if net_info is None or cp_info is None:
            self.logger.error('connect_cp_to_vnetwork',
            'Nor connection point or virtual network exist')
            return {'error':-2}
        net_dev = net_info.get('virtual_device')
        ext_cp = cp_info.get('ext_name')
        cmd = 'sudo ip link set dev {} master {}'.format(ext_cp, net_dev)
        self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})
        return {'result':{'int':cp_id, 'ext':vnet_id}}

    # eval
    def disconnect_cp(self, cp_id):
        cp_info = self.ports.get(cp_id)
        if cp_info is None:
            self.logger.error('disconnect_interface',
            'Connection point does not exist')
            return {'error':-2}
        ext_cp = cp_info.get('ext_name')
        cmd = 'sudo ip link set dev {} nomaster'.format(ext_cp)
        return {'result':{'int':cp_id, 'ext':None}}



    def remove_interface_from_network(self, network_uuid, intf_uuid):
        # net = self.networks.get(network_uuid, None)
        # if net is None:
        #     raise BridgeAssociatedToNetworkException(
        #         '{} network not exists'.format(network_uuid))
        # intf = self.brmap.get(intf_uuid, None)
        # if intf is None:
        #     raise InterfaceNotExistingException(
        #         '{} interface not exists'.format(intf_uuid))
        # if intf not in net.get('intf'):
        #     raise InterfaceNotInNetworkException(
        #         '{} interface not in this networks'.format(intf_uuid))

        # net.get('intf').remove(intf)
        # return True
        pass

    def delete_virtual_network(self, network_uuid):
        self.logger.info('delete_virtual_network()','Deletting {}'.format(network_uuid))
        net = self.networks.get(network_uuid, None)
        if net is None:
            raise BridgeAssociatedToNetworkException(
                '{} network not exists'.format(network_uuid))
        # if len(net.get('interfaces')) > 0:
        #     raise NetworkHasPendingInterfacesException(
        #         '{} has pending interfaces'.format(network_uuid))


        start_file, shutdown_file = self.net_files.get(network_uuid)

        shutdown_file = os.path.join(self.BASE_DIR, shutdown_file)
        start_file = os.path.join(self.BASE_DIR, start_file)
        # dnsmasq_file = os.path.join(
        #     self.BASE_DIR, self.DHCP_DIR, 'br-{}_dnsmasq.sh'.format(network_uuid.split('-')[0]))

        self.call_os_plugin_function('execute_command',{'command':'sudo {}'.format(shutdown_file),'blocking':True, 'external':True})
        self.call_os_plugin_function('remove_file',{'file_path':shutdown_file})
        self.call_os_plugin_function('remove_file',{'file_path':start_file})
        # self.call_os_plugin_function('remove_file',{'file_path':dnsmasq_file})
        m  = self.networks.pop(network_uuid)
        m.update({'status':'DESTROY'})
        self.net_files.pop(network_uuid)
        self.connector.loc.actual.add_node_network(self.node, self.uuid, network_uuid, m)
        self.logger.info('delete_virtual_network()','Deleted {}'.format(network_uuid))

        return True

    def stop_network(self):
        keys = list(self.networks.keys())
        for k in keys:
            self.delete_virtual_network(k)
        return True

    def get_network_info(self, network_uuid):
        if network_uuid is None:
            return self.networks
        return self.networks.get(network_uuid)


    def __cird2block(self, cird):
        '''
            Convert cird subnet to first address (for router), dhcp avaiable range, netmask

        :param cird:
        :return:
        '''
        (ip, cidr) = cird.split('/')
        cidr = int(cidr)
        host_bits = 32 - cidr
        netmask = socket.inet_ntoa(struct.pack(
            '!I', (1 << 32) - (1 << host_bits)))
        i = struct.unpack('>I', socket.inet_aton(ip))[0]
        start = (i >> host_bits) << host_bits
        end = i | ((1 << host_bits) - 1)

        return socket.inet_ntoa(struct.pack('>I', start + 1)), socket.inet_ntoa(
            struct.pack('>I', start + 2)), socket.inet_ntoa(struct.pack('>I', end - 1)), netmask

    def __get_net_size(self, netmask):
        binary_str = ''
        for octet in netmask:
            binary_str += bin(int(octet))[2:].zfill(8)
        return str(len(binary_str.rstrip('0')))

    def __ip_mask_to_cird(self, ip, mask):

        try:
            socket.inet_aton(ip)
            socket.inet_aton(mask)
        except:
            return "0.0.0.0/0"

        ip = ip.split('.')
        mask = mask.split('.')
        net_start = [str(int(ip[x]) & int(mask[x])) for x in range(0, 4)]
        return '.'.join(net_start) + '/' + self.__get_net_size(mask)


    def __net_observer(self, net_info):
        self.logger.info('__net_observer()', 'Linux Bridge Plugin - New Action of a Network - Net Info: {}'.format(net_info))
        action = net_info.get('status')
        net_uuid = net_info.get('uuid')
        if action == 'DESTROY':
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - This is a remove for : {}'.format(net_info))
            self.delete_virtual_network(net_uuid)
        elif action == 'CREATE':
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - This is a add for : {}'.format(net_info))
            self.create_virtual_network(net_info)
        else:
            self.logger.info('__net_observer()', 'Linux Bridge Plugin - Action not recognized : {}'.format(action))


    def __port_observer(self, port_info):
        self.logger.info('__port_observer()', 'Linux Bridge Plugin - New Action of a Port - Port Info: {}'.format(port_info))
        action = port_info.get('status')
        port_uuid = port_info.get('cp_uuid')
        if action == 'DESTROY':
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - This is a remove for : {}'.format(port_info))
            self.delete_port(port_uuid)
        elif action == 'CREATE':
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - This is a add for : {}'.format(port_info))
            self.create_port(port_info)
        else:
            self.logger.info('__port_observer()', 'Linux Bridge Plugin - Action not recognized : {}'.format(action))


    def __generate_interface_create_script(self, internal_name, external_name, name):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vface_creation.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(int_port=internal_name, ext_port=external_name)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'create_face_{}.sh'.format(name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_interface_destroy_script(self, external_name, name):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vface_destroy.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(ext_port=external_name)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'destroy_face_{}.sh'.format(name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name


    def __generate_port_create_script(self, internal_name, external_name, name):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'cp_creation.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(int_port=internal_name, ext_port=external_name, cp_name=name)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'create_port_{}.sh'.format(name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_port_destroy_script(self, external_name, name):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'cp_destroy.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(ext_port=external_name, cp_name=name)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'destroy_port_{}.sh'.format(name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_vnet_start_script(self, netid):

        hx = bytes.fromhex(netid)
        vals = struct.unpack('<{}B'.format(len(hx)), hx)
        vxlan_id = sum(vals)
        mcast_addr = '239.245.{}.{}'.format(vals[0], vals[1])

        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_create.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid, group_id=vxlan_id, mcast_group_address=mcast_addr, wan=self.overlay_interface)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'start_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name

    def __generate_vnet_stop_script(self, netid):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vnet_destroy.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(net_id=netid)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = 'stop_{}.sh'.format(netid)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name



    def __generate_vxlan_shutdown_script(self, net_uuid):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vxlan_destroy.sh'), 'root':False})
        br_name = 'br-{}'.format(net_uuid.split('-')[0])
        vxlan_name = 'vxl-{}'.format(net_uuid.split('-')[0])
        file_name = '{}_dnsmasq.pid'.format(br_name)
        pid_file_path = os.path.join(self.BASE_DIR, self.DHCP_DIR, file_name)
        net_sh = Environment().from_string(template_sh)
        net_sh = net_sh.render(
            bridge=br_name, vxlan_intf_name=vxlan_name, dnsmasq_pid_file=pid_file_path)
        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        self.logger.info('__generate_port_create_script()', 'File content : {}'.format(net_sh))
        file_name = '{}_stop.sh'.format(br_name)
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':file_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, file_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})

        return file_name
    def __generate_dnsmaq_script(self, br_name, start_addr, end_addr, listen_addr, pid_file):
        template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'dnsmasq.sh'), 'root':False})
        dnsmasq_sh = Environment().from_string(template_sh)
        dnsmasq_sh = dnsmasq_sh.render(bridge_name=br_name, dhcp_start=start_addr,
                                       dhcp_end=end_addr, listen_addr=listen_addr, pid_path=pid_file)
        file_name = '{}_dnsmasq.sh'.format(br_name)
        path = os.path.join(self.BASE_DIR, self.DHCP_DIR)
        self.call_os_plugin_function('store_file',{'content':dnsmasq_sh, 'file_path':path, 'filename':file_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(path, file_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return file_name

    def __generate_vxlan_script(self, net_uuid, manifest=None):
        if not self.overlay_interface:
            template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vxlan_creation.sh'), 'root':False})
        else:
            template_sh = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vxlan_creation_intf.sh'), 'root':False})
        net_sh = Environment().from_string(template_sh)
        br_name = 'br-{}'.format(net_uuid.split('-')[0])
        vxlan_name = 'vxl-{}'.format(net_uuid.split('-')[0])

        if manifest is not None:
            if manifest.get('overlay_info') is not None and manifest.get('overlay_info').get('vxlan_id') is not None:
                vxlan_id = manifest.get('overlay_info').get('vxlan_id')
            else:
                vxlan_id = len(self.networks) + 1
            if manifest.get('overlay_info') is not None and manifest.get('overlay_info').get('multicast_address') is not None:
                mcast_addr = manifest.get(
                    'overlay_info').get('multicast_address')
            else:
                mcast_addr = '239.0.0.{}'.format(vxlan_id)
        else:
            vxlan_id = len(self.networks) + 1
            mcast_addr = '239.0.0.{}'.format(vxlan_id)

        net_sh = net_sh.render(bridge_name=br_name, vxlan_intf_name=vxlan_name,
                               group_id=vxlan_id, mcast_group_address=mcast_addr, wan=self.overlay_interface)

        net_sh = binascii.hexlify(base64.b64encode(bytes(net_sh,'utf-8'))).decode()
        f_name = '{}.sh'.format(net_uuid.split('-')[0])
        self.call_os_plugin_function('store_file',{'content':net_sh, 'file_path':self.BASE_DIR, 'filename':f_name})
        chmod_cmd = 'chmod +x {}'.format(os.path.join(self.BASE_DIR, f_name))
        self.call_os_plugin_function('execute_command',{'command':chmod_cmd,'blocking':True, 'external':False})
        return f_name, vxlan_name, vxlan_id, mcast_addr

def read_file(file_path):
    data = ''
    with open(file_path, 'r') as f:
        data = f.read()
    return data


if __name__ == '__main__':
    if len(sys.argv) < 2:
        exit(-1)
    print('ARGS {}'.format(sys.argv))
    file_dir = os.path.dirname(__file__)
    manifest = json.loads(read_file(sys.argv[1]))
    nm = LinuxBridge(manifest.get('name'), manifest.get('version'), manifest.get(
        'uuid'), manifest)
    nm.start_network_manager()
