#!/usr/bin/env python3

# Copyright (c) 2014,2018 ADLINK Technology Inc.
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
# which is available at https://www.apache.org/licenses/LICENSE-2.0.
#
# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
#
# Contributors: Gabriele Baldoni, ADLINK Technology Inc. - Base plugins set


import sys
import os
import signal
import uuid
import json
import random
import time
import re
import threading
from packaging import version
from jinja2 import Environment
from pylxd import Client
from pylxd.exceptions import LXDAPIException
from mvar import MVar
from fog05.interfaces.States import State
from fog05.interfaces.RuntimePluginFDU import *
from LXDFDU import LXDFDU


class LXD(RuntimePluginFDU):

    def __init__(self, name, version, plugin_uuid, manifest):

        super(LXD, self).__init__(name, version, plugin_uuid, manifest)
        self.pid = os.getpid()
        self.var = MVar()

        self.wait_dependencies()

        self.agent_conf = \
            self.connector.loc.actual.get_node_configuration(self.node)

        self.logger.info('__init__()', ' Hello from LXD Plugin')
        self.BASE_DIR = os.path.join(
            self.agent_conf.get('agent').get('path'),'lxd')
        self.DISK_DIR = 'disks'
        self.IMAGE_DIR = 'images'
        self.LOG_DIR = 'logs'

        self.IMAGE_SERVER = "https://images.linuxcontainers.org/"

        self.UBUNTU_IMAGE_SERVER = "https://cloud-images.ubuntu.com/releases"

        file_dir = os.path.dirname(__file__)
        self.DIR = os.path.abspath(file_dir)
        self.update_interval =  manifest.get('configuration').get('update_interval', 10)
        self.lxd_storage_pool = manifest.get('configuration').get('storage_pool', 'default')

        self.conn = None
        self.images = {}
        self.flavors = {}

        self.mon_instances = []

        self.mon_th = None
        self.mon_run = False


        d = {
            'connect_interface_to_cp': self.connect_interface_to_cp,
            'disconnect_interface_from_cp': self.disconnect_interface_from_cp,
        }

        for k in d:
            f = d.get(k)
            self.logger.info(
                '__init__()', 'LXD Plugin - Registering {}'.format(k))
            self.connector.loc.actual.add_plugin_eval(self.node, self.uuid, k, f)


        signal.signal(signal.SIGINT, self.__catch_signal)
        signal.signal(signal.SIGTERM, self.__catch_signal)

    def __catch_signal(self, signal, _):
        if signal in [2,15]:
            self.var.put(signal)

    def read_binary_file(self, file_path):
        data = None
        with open(file_path, 'rb') as f:
            data = f.read()
        return data

    def start_runtime(self):
        self.logger.info(
            'start_runtime()', ' LXD Plugin - Connecting to LXD')
        try:
            self.conn = Client()
        except:
            self.conn = Client(endpoint='https://127.0.0.1:8443', verify=False)

        self.logger.info(
            'start_runtime()', '[ DONE ] LXD Plugin - Connecting to LXD')


        '''check if dirs exists if not exists create'''
        if self.os.dir_exists(self.BASE_DIR):
            if not self.os.dir_exists(os.path.join(self.BASE_DIR, self.DISK_DIR)):
                self.os.create_dir(os.path.join(self.BASE_DIR, self.DISK_DIR))
            if not self.os.dir_exists(os.path.join(self.BASE_DIR, self.IMAGE_DIR)):
                self.os.create_dir(os.path.join(self.BASE_DIR, self.IMAGE_DIR))
            if not self.os.dir_exists(os.path.join(self.BASE_DIR, self.LOG_DIR)):
                self.os.create_dir(os.path.join(self.BASE_DIR, self.LOG_DIR))
        else:
            self.os.create_dir(os.path.join(self.BASE_DIR))
            self.os.create_dir(os.path.join(self.BASE_DIR, self.DISK_DIR))
            self.os.create_dir(os.path.join(self.BASE_DIR, self.IMAGE_DIR))
            self.os.create_dir(os.path.join(self.BASE_DIR, self.LOG_DIR))


        self.connector.loc.desired.observe_node_runtime_fdus(self.node, self.uuid, self.__fdu_observer)

        self.manifest.update({'pid': self.pid})
        self.manifest.update({'status': 'running'})
        self.connector.loc.actual.add_node_plugin(self.node, self.uuid, self.manifest)

        self.mon_run =  True
        mt = threading.Thread(target=self.__monitor_instance, daemon=True)
        mt.start()
        self.mon_th = mt

        self.logger.info('start_runtime()', ' LXD Plugin - Started...')

        r = self.var.get()
        self.stop_runtime()
        self.connector.close()
        exit(0)


    def stop_runtime(self):
        self.logger.info(
            'stop_runtime()', 'LXD Plugin - Destroying {} running FDUs'.format(len(self.current_fdus)))
        for k in list(self.current_fdus.keys()):
            # TODO verify this
            try:
                fdu = self.current_fdus.get(k)
                self.__force_fdu_termination(k)
            except Exception as e:
                self.logger.error('stop_runtime()', 'Error {}, continuing'.format(e))
                pass

            # if fdu.get_status() == State.DEFINED:
            #     self.undefine_fdu(k)
        keys = list(self.images.keys())
        for k in keys:
            self.logger.info(
                'stop_runtime()', 'Removing Image {}'.format(k))
            try:
                img = self.conn.images.get_by_alias(k)
                imgd = self.images[k]
                try:
                    self.os.remove_file(os.path.join(self.BASE_DIR, self.IMAGE_DIR, imgd['base_image']))
                except ValueError:
                     self.logger.info('stop_runtime()', 'Removing Image file {} not exist'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, imgd['base_image'])))
                img.delete()
            except LXDAPIException as e:
                self.logger.error('stop_runtime()', 'Error {}'.format(e))
                pass

        self.conn = None
        self.logger.info('stop_runtime()', '[ DONE ] LXD Plugin - Bye Bye')

    def get_fdus(self):
        return self.current_fdus

    def define_fdu(self, fdu_record):
        self.logger.info('define_fdu()', ' LXD Plugin - Defining a Container')
        fdu = LXDFDU(fdu_record)
        fdu_uuid = fdu.get_fdu_id()
        instance_id = fdu.get_uuid()

        if instance_id in self.current_fdus:
            self.logger.error('define_fdu()', '[ ERRO ] LXD Plugin - Instance with ID {} already defined!!'.format(instance_id))
            self.write_fdu_error(fdu_uuid, instance_id, 0, 'Instance with this ID {} already exists!'.format(instance_id))


        if self.is_uuid(fdu.get_image_uri()):
            img_info = self.agent.get_image_info(fdu.get_image_uri())
            self.logger.info('define_fdu()', '[ INFO ] LXD Plugin - Img info: {}'.format(img_info))
            # img_info = self.images.get(fdu.get_image_uri(), None)
            if img_info is None:
                self.logger.error('define_fdu()', '[ ERRO ] LXD Plugin - Cannot find image {}'.format(fdu.get_image_uri()))
                self.write_fdu_error(fdu_uuid, instance_id, 0, 'Cannot find image!')
                return

            fdu.set_image_uri(img_info.get('uri'))
            fdu.set_image_uuid(img_info.get('uuid'))

        image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])

        if not self.os.file_exists(image_name) :
            if fdu.get_image_uri().startswith('http'):
                self.os.download_file(fdu.get_image_uri(),image_name)
            elif fdu.get_image_uri().startswith('file://'):
                cmd = 'cp {} {}'.format(fdu.get_image_uri()[len('file://'):], image_name)
                self.os.execute_command(cmd,blocking=True)

        # TODO verify IMAGE CHECKSUM
        img_info = {}
        try:

            if fdu.get_image_uri().startswith('lxd://') or fdu.get_image_uri().startswith('ubuntu://'):
                try:
                    if fdu.get_image_uri().startswith('lxd://'):
                        img_alias = fdu.get_image_uri()[6:]
                        self.logger.info('define_fdu()','Image is coming from LXD repository: {}'.format(img_alias))
                        lxd_img = self.conn.images.create_from_simplestreams(server=self.IMAGE_SERVER, alias=img_alias)
                    else:
                        img_alias = fdu.get_image_uri()[9:]
                        self.logger.info('define_fdu()','Image is coming from Ubuntu repository: {}'.format(img_alias))
                        lxd_img = self.conn.images.create_from_simplestreams(server=self.UBUNTU_IMAGE_SERVER, alias=img_alias)
                    lxd_img.add_alias(fdu_uuid, description='')
                except LXDAPIException as e:
                    self.logger.info('define_fdu()', '[ ERRO ] LXD Plugin - LXDAPIException when fetching image: {}'.format(e))
                    if '{}'.format(e) == 'Image with same fingerprint already exists':
                        self.logger.info('define_fdu()', '[ INFO ] LXD Plugin - Image with same fingerprint already exists')
                    if '{}'.format(e) == 'The requested image couldn\'t be found':
                        self.logger.info('define_fdu()', '[ ERRO ] LXD Plugin - Unable to find LXD image')
                        self.write_fdu_error(fdu_uuid, instance_id, 0, 'Cannot find image!')
                        return

                image_name = ''
                img_info.update({'uuid': fdu_uuid})
                img_info.update({'name': '{}_img'.format(fdu.name)})
                img_info.update({'base_image': image_name})
                img_info.update({'type': 'lxd'})
                img_info.update({'format': 'lxd'})
                self.images.update({fdu_uuid: img_info})
                self.connector.loc.actual.add_node_image(self.node, self.uuid, fdu_uuid, img_info)


            else:
                # TODO: this should some how pass through YAKS, at this time the LXD plugin will read
                # the file from the disk

                img_sum = self.os.checksum(image_name)
                if self.conn.images.exists(img_sum):
                    self.logger.info('define_fdu()', '[ INFO ] LXD Plugin - Image with this fingerprint already exists, attaching it to container')
                    img =  self.conn.images.get(img_sum)
                    img_uuid = img.aliases[0].get('name')
                    img_info.update({'uuid': img_uuid})
                    img_info.update({'name': '{}_img'.format(fdu.name)})
                    img_info.update({'base_image': image_name})
                    img_info.update({'type': 'lxd'})
                    img_info.update({'format': fdu.get_image_format()})
                else:
                    self.logger.info('define_fdu()', '[ INFO ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name)))
                    image_data = self.read_binary_file(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name))
                    self.logger.info('define_fdu()', '[ DONE ] LXD Plugin - Loaded image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name)))

                    self.logger.info('define_fdu()', '[ INFO ] LXD Plugin - Creating image with alias {}'.format(fdu_uuid))
                    try:
                        img = self.conn.images.create(image_data, public=True, wait=True)
                        img.add_alias(fdu_uuid, description=fdu.name)
                    except LXDAPIException as e:
                        # TODO: check this error with errno
                        if '{}'.format(e) == 'Image with same fingerprint already exists':
                            self.logger.info('define_fdu()', '[ INFO ] LXD Plugin - Image with same fingerprint already exists')
                            pass


                    self.logger.info('define_fdu()', '[ DONE ] LXD Plugin - Created image with alias {}'.format(fdu_uuid))
                    img_info.update({'uuid': fdu_uuid})
                    img_info.update({'name': '{}_img'.format(fdu.name)})
                    img_info.update({'base_image': image_name})
                    img_info.update({'type': 'lxd'})
                    img_info.update({'format': fdu.get_image_format()})
                    self.images.update({fdu_uuid: img_info})
                    self.connector.loc.actual.add_node_image(self.node, self.uuid, fdu_uuid, img_info)

            fdu.set_image_uri(img_info.get('uri'))
            fdu.set_image_uuid(img_info.get('uuid'))



        except LXDAPIException as e:
            self.logger.error('define_fdu()', 'Error {}'.format(e))
            self.write_fdu_error(fdu_uuid, instance_id, 0, e)
            self.logger.info('define_fdu()', '[ ERRO ] LXD Plugin - Container uuid: {}'.format(fdu_uuid))
            return



        fdu.set_status(State.DEFINED)
        # if fdudata.get('devices'):
        #     fdu.devices = json.loads(fdudata.get('devices'))
        self.current_fdus.update({instance_id: fdu})
        self.update_fdu_status(fdu_uuid, instance_id, 'DEFINE')
        self.logger.info('define_fdu()', '[ DONE ] LXD Plugin - Container uuid: {}'.format(instance_id))



    def undefine_fdu(self, instance_uuid):

        self.logger.info('undefine_fdu()', ' LXD Plugin - Undefine a Container uuid {}'.format(instance_uuid))
        fdu = self.current_fdus.get(instance_uuid, None)
        if fdu is None:
            self.logger.error('undefine_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(instance_uuid, self.uuid))
        elif fdu.get_status() != State.DEFINED:
            self.logger.error('undefine_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in DEFINED state',
                                                     'FDU {} is not in DEFINED state'.format(instance_uuid))
        else:
            fdu_uuid  = fdu.get_fdu_id()
            try:
                self.logger.info('undefine_fdu()', '[ INFO ] LXD Plugin - Container Name {}'.format(fdu.name))
                c = self.conn.containers.get(fdu.name)
                c.delete()
            except Exception as e:
                self.logger.info('undefine_fdu()', '[ ERRO ] LXD Plugin - Undefine a Container Exception raised {}'.format(e))
                fdu.status = 'ERROR'
                self.current_fdus.update({instance_uuid: fdu})
                self.write_fdu_error(fdu_uuid, instance_uuid, 1, e)
                return


            try:
                time.sleep(2)
                profile = self.conn.profiles.get(instance_uuid)
                profile.sync()
                while True:
                    if len(profile.used_by) == 0:
                        break
                    profile.sync()
                    time.sleep(1)
                profile.delete()
            except Exception as e:
                self.logger.info('undefine_fdu()', '[ ERRO ] LXD Plugin - Undefine a Container Exception raised {}'.format(e))

            if self.get_local_instances(fdu_uuid) == 1:
                try:
                    image_id = fdu.image.get('uuid')
                    img = self.conn.images.get_by_alias(image_id)
                    img.delete()
                    image_name = self.images.get(image_id)['base_image']
                    self.os.remove_file(image_name)
                    self.images.pop(image_id)
                    self.os.remove_file(image_name)
                except Exception as e:
                    self.logger.info('undefine_fdu()', '[ ERRO ] LXD Plugin - Undefine a Container Exception raised {}'.format(e))

            self.current_fdus.pop(instance_uuid, None)
            self.connector.loc.actual.remove_node_fdu(self.node, self.uuid, fdu_uuid, instance_uuid)
            self.logger.info('undefine_fdu()', '[ DONE ] LXD Plugin - Undefine a Container uuid {}'.format(instance_uuid))
            return True

    def configure_fdu(self, instance_uuid):

        self.logger.info('configure_fdu()', ' LXD Plugin - Configure a Container uuid {} '.format(instance_uuid))
        fdu = self.current_fdus.get(instance_uuid, None)
        if fdu is None:
            self.logger.error('configure_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(instance_uuid, self.uuid))
        elif fdu.get_status() != State.DEFINED:
            self.logger.error('configure_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in DEFINED state',
                                                     'FDU {} is not in DEFINED state'.format(instance_uuid))
        else:
            fdu_uuid = fdu.get_fdu_id()
            record = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid,instance_uuid)
            record = InfraFDU(record)

            self.logger.info('configure_fdu()', '[ INFO ] LXD Plugin - Creating profile...')
            try:

                custom_profile_for_fdu = self.conn.profiles.create(instance_uuid)




                conf = {'environment.FOSUUID': fdu_uuid,
                        'environment.FOSINSTANCEUUID': instance_uuid,
                        'environment.FOSNODEUUID': self.node,
                        'limits.cpu': str(fdu.get_computation_requirements().get('cpu_min_count')),
                        'limits.memory':'{}MB'.format(int(fdu.get_computation_requirements().get('ram_size_mb')))
                        }

                if fdu.get_configuration() is not None:
                    if fdu.get_configuration().conf_type in ['CLOUD_INIT']:
                        c_init_file = fdu.get_configuration().script
                        self.logger.info('configure_fdu()', '[ INFO ] LXD Plugin - FDU has configuration: {}'.format(c_init_file))
                        conf = self.__generate_custom_profile_userdata_configuration(c_init_file, conf)


                for cp in fdu.get_connection_points():
                    cp_id = cp.get('uuid')
                    # cp_record = {
                    #     'cp_uuid':cp_id,
                    #     'status':'CREATE'
                    # }
                    self.connector.loc.desired.add_node_port(self.node, self.nm.uuid, cp_id, cp)
                    res = self.connector.loc.actual.get_node_port(self.node, self.nm.uuid, cp_id)
                    while res is None:
                        res = self.connector.loc.actual.get_node_port(self.node, self.nm.uuid, cp_id)
                    cp.update({'status' :'CONNECTED'})
                    # record.get('connection_points').append(cp_id)

                dev, interfaces = self.__generate_custom_profile_devices_configuration(fdu)

                record.set_interfaces(interfaces)
                self.logger.info('configure_fdu()', '[ INFO ] Profile devices {}'.format(dev))
                # if fdu.devices:
                #     for d in fdu.devices:
                #         dev.update(d)
                self.logger.info('__generate_custom_profile_devices_configuration()', 'LXD Plugin - Devices {}'.format(dev))
                custom_profile_for_fdu.config = conf
                custom_profile_for_fdu.devices = dev
                custom_profile_for_fdu.save()

            except LXDAPIException as e:
                self.logger.error('configure_fdu()', 'Error {}'.format(e))
                fdu.set_status('ERROR')
                self.current_fdus.update({instance_uuid: fdu})
                self.write_fdu_error(fdu_uuid, instance_uuid, 2, e)
                return

            self.logger.info('configure_fdu()', '[ DONE ] LXD Plugin - Creating profile...')
            if fdu.profiles is None:
                fdu.profiles = list()

            fdu.profiles.append(instance_uuid)

            self.logger.info('configure_fdu()', '[ INFO ] LXD Plugin - Generating container configuration...')
            config = self.__generate_container_dict(fdu)
            self.logger.info('configure_fdu()', '[ DONE ] LXD Plugin - Generating container configuration...')

            self.logger.info('configure_fdu()', '[ INFO ] LXD Plugin - Creating Container...')
            try:
                self.conn.containers.create(config, wait=True)
            except LXDAPIException as e:
                self.logger.error('configure_fdu()', 'Error {}'.format(e))
                self.logger.error('configure_fdu()', 'Config {}'.format(config))
                fdu.set_status('ERROR')
                self.current_fdus.update({instance_uuid: fdu})
                self.write_fdu_error(fdu_uuid, instance_uuid, 2, e)
                return

            self.logger.info('configure_fdu()', '[ INFO ] LXD Plugin - Container Name {}'.format(fdu.name))
            self.logger.info('configure_fdu()', '[ DONE ] LXD Plugin - Creating Container...')

            fdu.on_configured(config)

            self.current_fdus.update({instance_uuid: fdu})

            record.set_status('CONFIGURE')
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid,instance_uuid, record.to_json())
            # self.update_fdu_status(fdu_uuid, instance_uuid, 'CONFIGURE')

            # TODO: monitoring TBA
            # this monitoring uses pylxd to get container information

            self.mon_instances.append((fdu_uuid, instance_uuid, fdu.name))

            self.logger.info('run_fdu()', '[ DONE ] LXD Plugin - Starting a Monitoring of {}'.format(instance_uuid))

    def clean_fdu(self, instance_uuid):

        self.logger.info('clean_fdu()', ' LXD Plugin - Clean a Container uuid {}'.format(instance_uuid))
        fdu = self.current_fdus.get(instance_uuid, None)
        if fdu is None:
            self.logger.error('clean_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(instance_uuid, self.uuid))
        elif fdu.get_status() != State.CONFIGURED:
            self.logger.error('clean_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in CONFIGURED state',
                                                     'FDU {} is not in CONFIGURED state'.format(instance_uuid))
        else:

            fdu.on_clean()
            fdu_uuid = fdu.get_fdu_id()
            i = 0
            for intf in fdu.get_interfaces():
                intf_name = intf.get('vintf_name')
                if intf.get('virtual_interface').get('intf_type').upper() not in ['PHYSICAL','BRIDGED']:
                    intf_id = 'lxd-{}-{}'.format(fdu.get_short_id(), i)
                    self.logger.info('clean_fdu()','Asking for the deletion of virtual interface {}'.format(intf_id))
                    self.nm.delete_virtual_interface(intf_id)
                    self.logger.info('clean_fdu()','virtual interface {} removed'.format(intf_id))
                else:
                    real_intf_name = intf.get('phy_face')
                    self.os.set_interface_available(real_intf_name)
                i += 1
            for cp in fdu.get_connection_points():
                self.logger.info('clean_fdu()', 'LXD Plugin - CP: {}'.format(cp))
                cp_id = cp.get('uuid')
                self.logger.info('clean_fdu()','Asking for the deletion of connetion_point {}'.format(cp_id))
                cp = self.connector.loc.actual.get_node_port(self.node, self.nm.uuid, cp_id)
                cp.update({'status' :'DESTROY'})
                self.connector.loc.desired.add_node_port(self.node, self.nm.uuid, cp_id, cp)
                # self.nm.delete_port(cp_id)

            self.current_fdus.update({instance_uuid: fdu})
            self.update_fdu_status(fdu_uuid, instance_uuid, 'DEFINE')
            self.logger.info('clean_fdu()', '[ DONE ] LXD Plugin - Clean a Container uuid {} '.format(instance_uuid))

            return True

    def run_fdu(self, instance_uuid):
        self.logger.info('run_fdu()', ' LXD Plugin - Starting a Container uuid {}'.format(instance_uuid))
        fdu = self.current_fdus.get(instance_uuid, None)
        if fdu is None:
            self.logger.error('run_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(instance_uuid, self.uuid))
        elif fdu.get_status() != State.CONFIGURED:
            self.logger.error('run_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in CONFIGURED state',
                                                     'FDU {} is not in CONFIGURED state'.format(instance_uuid))
        else:
            fdu_uuid = fdu.get_fdu_id()
            self.current_fdus.update({instance_uuid: fdu})
            self.update_fdu_status(fdu_uuid, instance_uuid, 'STARTING')
            self.logger.info('run_fdu()', '[ INFO ] LXD Plugin - Container Name {}'.format(fdu.name))
            c = self.conn.containers.get(fdu.name)
            c.start()
            while c.status != 'Running':
                try:
                    c.sync()
                except Exception as e:
                    self.logger.info('run_fdu()', '[ ERR ] LXD Plugin - {}'.format(e))
                    fdu.status = 'ERROR'
                    self.current_fdus.update({instance_uuid: fdu})
                    self.write_fdu_error(fdu_uuid, instance_uuid, 4, e)
                    return

            fm = c.FilesManager(self.conn, c)
            envs = 'export FOSUUID={} \n' \
                    'environment.FOSINSTANCEUUID={} \n' \
                    'export FOSNODEUUID={}'\
                .format(fdu_uuid,instance_uuid , self.node)
            fm.put('/etc/profile.d/99-fos', envs, mode="0644")
            fdu.on_start()

            self.mon_instances.remove((fdu_uuid, instance_uuid, fdu.name))

            self.current_fdus.update({instance_uuid: fdu})
            self.update_fdu_status(fdu_uuid, instance_uuid, 'RUN')
            self.logger.info('run_fdu()', '[ DONE ] LXD Plugin - Starting a Container uuid {}'.format(instance_uuid))



    def stop_fdu(self, instance_uuid):
        self.logger.info('stop_fdu()', ' LXD Plugin - Stop a Container uuid {}'.format(instance_uuid))
        fdu = self.current_fdus.get(instance_uuid, None)
        if fdu is None:
            self.logger.error('stop_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(instance_uuid, self.uuid))
        elif fdu.get_status() != State.RUNNING:
            self.logger.error('stop_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in RUNNING state',
                                                     'FDU {} is not in RUNNING state'.format(instance_uuid))
        else:
            fdu_uuid = fdu.get_fdu_id()
            self.logger.info('stop_fdu()', '[ INFO ] LXD Plugin - Container Name {}'.format(fdu.name))
            c = self.conn.containers.get(fdu.name)
            # self.mon_th.pop(fdu_uuid)
            try:
                c.stop(force=True, wait=True)
                c.sync()

                while c.status != 'Stopped':
                    c.sync()
            except Exception as e:
                    self.logger.info('stop_fdu()', '[ ERR ] LXD Plugin - {}'.format(e))
                    fdu.status = 'ERROR'
                    self.current_fdus.update({instance_uuid: fdu})
                    self.write_fdu_error(fdu_uuid, instance_uuid, 5, e)
                    return

            fdu.on_stop()

            self.current_fdus.update({instance_uuid: fdu})
            self.update_fdu_status(fdu_uuid, instance_uuid, 'CONFIGURE')
            self.logger.info('stop_fdu()', '[ DONE ] LXD Plugin - Stop a Container uuid {}'.format(instance_uuid))

    def pause_fdu(self, instance_uuid):
        self.logger.info('pause_fdu()', ' LXD Plugin - Pause a Container uuid {}'.format(instance_uuid))
        fdu = self.current_fdus.get(instance_uuid, None)
        if fdu is None:
            self.logger.error('pause_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(instance_uuid, self.uuid))
        elif fdu.get_status() != State.RUNNING:
            self.logger.error('pause_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in RUNNING state',
                                                     'FDU {} is not in RUNNING state'.format(instance_uuid))
        else:
            fdu_uuid = fdu.get_fdu_id()
            self.logger.info('pause_fdu()', '[ INFO ] LXD Plugin - Container Name {}'.format(fdu.name))
            c = self.conn.containers.get(fdu.name)
            c.freeze()

            fdu.on_pause()
            self.current_fdus.update({instance_uuid: fdu})
            self.update_fdu_status(fdu_uuid, instance_uuid, 'PAUSE')
            self.logger.info('pause_fdu()', '[ DONE ] LXD Plugin - Pause a Container uuid {}'.format(instance_uuid))

    def resume_fdu(self, instance_uuid):
        self.logger.info('resume_fdu()', ' LXD Plugin - Resume a Container uuid {}'.format(instance_uuid))
        fdu = self.current_fdus.get(instance_uuid, None)
        if fdu is None:
            self.logger.error('resume_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(instance_uuid, self.uuid))
        elif fdu.get_status() != State.PAUSED:
            self.logger.error('resume_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in PAUSED state',
                                                     'FDU {} is not in PAUSED state'.format(instance_uuid))
        else:
            fdu_uuid = fdu.get_fdu_id()
            self.logger.info('resume_fdu()', '[ INFO ] LXD Plugin - Container Name {}'.format(fdu.name.replace('_','-')[:63]))
            c = self.conn.containers.get(fdu.name)
            c.unfreeze()

            fdu.on_resume()
            self.current_fdus.update({instance_uuid: fdu})
            self.update_fdu_status(fdu_uuid, instance_uuid, 'RUN')
            self.logger.info('resume_fdu()', '[ DONE ] LXD Plugin - Resume a Container uuid {}'.format(instance_uuid))



    def migrate_fdu(self, instance_uuid):
        record = self.connector.loc.desired.get_node_fdu(self.node, self.uuid, '*', instance_uuid)
        record = LXDFDU(record)
        fdu_uuid = record.get_fdu_id()
        destination = record.get_migration_properties().get('destination')
        if destination != self.node:
            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Source Node preparation...')
            fdu = self.current_fdus.get(instance_uuid, None)
            if fdu is None:
                self.logger.error('migrate_fdu','LXD not in Runtime!!')
                fdu.set_status('ERROR')
                self.current_fdus.update({instance_uuid: fdu})
                self.write_fdu_error(fdu_uuid, instance_uuid, 7, 'Instance not present in node')
                return

            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, instance_uuid, record)
            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Source Node wait destination...')
            self.wait_destination_ready(fdu_uuid, instance_uuid, destination)

            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Start Migrating...')

            # ACTUAL MIGRATION #
            #
            dst_ip = self.agent.get_node_mgmt_address(destination).get('ipv4_address')
            # this can also be v6 both information are available
            local_ip = self.get_local_mgmt_address().get('v4')

            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Local IP {} Destination IP {}'.format(dst_ip,local_ip))

            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Migrating...')

            path_cert = os.path.join(self.DIR, 'templates', 'lxd.crt')
            path_key = os.path.join(self.DIR, 'templates', 'lxd.key')

            remote_client = Client(endpoint='https://{}:8443'.format(dst_ip), cert=(path_cert, path_key), verify=False)
            local_client = Client(endpoint='https://{}:8443'.format(local_ip), cert=(path_cert, path_key), verify=False)

            remote_client.authenticate('fos')
            local_client.authenticate('fos')
            # TODO this should go in the plugin configuration, same for certificate and key

            cont = local_client.containers.get(fdu.name.replace('_','-')[:63])

            try:
                cont.stop(force=False, wait=True)
                cont.sync()
                cont.migrate(remote_client, wait=True)
            except LXDAPIException as e:
                self.logger.info('migrate_fdu()', ' LXD Plugin - LXD error {}'.format(e))
                cont.delete()

            self.logger.info('migrate_fdu()', ' LXD Plugin - Migration Source: Migration succeeds')
            remote_client = None
            local_client = None
            fdu.on_stop()
            self.current_fdus.update({instance_uuid: fdu})
            self.clean_fdu(instance_uuid)
            self.undefine_fdu(instance_uuid)
            self.logger.info('migrate_fdu()', ' LXD Plugin - Source is Clean')

            #
            #
        else:
            record.set_status('DEFINE')
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, instance_uuid, record)
            fdu = LXDFDU(record)


            self.logger.info('migrate_fdu()', '[ INFO ] LXD Plugin - Destination Node creating image and flavor...')

            if self.is_uuid(fdu.get_image_uri()):
                img_info = self.images.get(fdu.get_image_uri(), None)
                if img_info is None:
                    self.logger.error('migrate_fdu()', '[ ERRO ] LXD Plugin - Cannot find image {}'.format(fdu.get_image_uri()))
                    # TODO write error

                fdu.set_image_uri(img_info.get('uri'))
                fdu.set_image_uuid(img_info.get('uuid'))
            else:
                image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])

                if not self.os.file_exists(image_name):
                    if fdu.get_image_uri().startswith('http'):
                        self.os.download_file(fdu.get_image_uri(),image_name)
                    elif fdu.get_image_uri().startswith('file://'):
                        cmd = 'cp {} {}'.format(fdu.get_image_uri()[len('file://'):], image_name)
                        self.os.execute_command(cmd, blocking=True)
                img_info = {}
                try:
                    img_sum = self.os.checksum(image_name)
                    if self.conn.images.exists(img_sum):
                        self.logger.info('migrate_fdu()', '[ INFO ] LXD Plugin - Image with this fingerprint already exists, attaching it to container')
                        img =  self.conn.images.get(img_sum)
                        img_uuid = img.aliases[0].get('name')
                        img_info.update({'uuid': img_uuid})
                        img_info.update({'name': '{}_img'.format(fdu.name)})
                        img_info.update({'base_image': image_name})
                        img_info.update({'type': 'lxd'})
                        img_info.update({'format': fdu.get_image_format()})
                    else:
                        self.logger.info('migrate_fdu()', '[ INFO ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name)))
                        image_data = self.read_binary_file(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name))
                        self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name)))

                        self.logger.info('migrate_fdu()', '[ INFO ] LXD Plugin - Creating image with alias {}'.format(fdu_uuid))
                        try:
                            img = self.conn.images.create(image_data, public=True, wait=True)
                            img.add_alias(fdu_uuid, description=fdu.name)
                        except LXDAPIException as e:
                            # TODO: check this error with errno
                            if '{}'.format(e) == 'Image with same fingerprint already exists':
                                self.logger.info('migrate_fdu()', '[ INFO ] LXD Plugin - Image with same fingerprint already exists')
                                pass
                        self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Created image with alias {}'.format(fdu_uuid))
                        img_info.update({'uuid': fdu_uuid})
                        img_info.update({'name': '{}_img'.format(fdu.name)})
                        img_info.update({'base_image': image_name})
                        img_info.update({'type': 'lxd'})
                        img_info.update({'format': fdu.get_image_format()})
                        self.images.update({fdu_uuid: img_info})
                        self.connector.loc.actual.add_node_image(self.node, self.uuid, fdu_uuid, img_info)

                    fdu.set_image_uri(img_info.get('uri'))
                    fdu.set_image_uuid(img_info.get('uuid'))



                except LXDAPIException as e:
                    self.logger.error('define_fdu()', 'Error {}'.format(e))
                    record.set_status('ERROR')
                    self.current_fdus.update({instance_uuid: fdu})
                    self.write_fdu_error(fdu_uuid, instance_uuid, 7, e)
                    self.logger.info('define_fdu()', '[ ERRO ] LXD Plugin - Container uuid: {}'.format(fdu_uuid))
                    return

            # cpu = fdu.get_computation_requirements().get('cpu_min_count')
            # mem = fdu.get_computation_requirements().get('ram_size_mb')
            # disk_size = fdu.get_computation_requirements().get('storage_size_gb')
            # flavor = {
            #     'name': '{}_flavor'.format(fdu.name),
            #     'uuid': fdu_uuid,
            #     'cpu': cpu,
            #     'memory': mem,
            #     'disk_size': disk_size,
            #     'type':'lxd'
            #     }
            # fdu.get_computation_requirements().update({'uuid': fdu_uuid})

            # fl_uuid  = flavor.get('uuid')
            # self.flavors.update({fl_uuid: flavor})
            # self.connector.loc.actual.add_node_flavor(self.node, self.uuid, fl_uuid, flavor)

            # vNetwork configurations
            for cp in fdu.get_connection_points().values():
                cp_id = cp.get('uuid')
                # cp_record = {
                #     'cp_uuid':cp_id,
                #     'status':'CREATE'}
                self.connector.loc.desired.add_node_port(self.node, self.nm.uuid, cp_id,cp)
                res = self.connector.loc.actual.get_node_port(self.node, self.nm.uuid, cp_id)
                while res is None:
                    res = self.connector.loc.actual.get_node_port(self.node, self.nm.uuid, cp_id)
                cp.update({'status' :'CONNECTED'})
            i = 0
            for intf in fdu.get_interfaces().values():
                intf_name = intf.get('vintf_name')
                mac = intf.get('mac_address', self.__generate_random_mac())
                intf.update({'mac_address': mac})
                if intf.get('virtual_interface').get('intf_type').upper() in ['PHYSICAL','BRIDGED']:
                    real_intf_name = intf.get('phy_face')
                    if self.os.get_intf_type(real_intf_name) in ['ethernet']:
                        self.os.set_interface_unaviable(real_intf_name)
                    elif self.os.get_intf_type(real_intf_name) in ['wireless']:
                        self.os.set_interface_unaviable(real_intf_name)
                    else:
                        pass
                else:
                    intf_id = 'lxd-{}-{}'.format(fdu.get_short_id(), i)
                    intf_data = self.nm.create_virtual_interface(intf_id, intf)
                    self.logger.info('migrate_fdu()','LXD Plugin - Interface info {}'.format(intf_data))
                i += 1

            record.set_status('LAND')
            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Record {}'.format(record))
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, instance_uuid, record)
            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Destination Node is ready for {}'.format(instance_uuid))

            # DESTINATION IS READY WAITING CONTAINER

            while True:
                try:
                    c = self.conn.containers.get(fdu.name)
                    c.start()
                    if c.status.upper() == 'running'.upper():
                        break
                    else:
                        c.sync()
                        self.logger.info('migrate_fdu()',  ' LXD Plugin - Container in this host but not running')
                except Exception as e:
                   self.logger.info('migrate_fdu()', ' LXD Plugin - Container not already in this host')
                time.sleep(2)

            fdu.on_start()
            self.current_fdus.update({instance_uuid: fdu})
            record.set_migration_properties('','')
            record.set_status('RUN')
            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Record {}'.format(record.to_json()))
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, instance_uuid,record.to_json())
            self.logger.info('migrate_fdu()', '[ DONE ] LXD Plugin - Migrate a Container uuid {}'.format(instance_uuid))



    def before_migrate_entity_actions(self, fdu_uuid, dst=False):
        pass

    def after_migrate_entity_actions(self, fdu_uuid, dst=False):
        pass



    def connect_interface_to_cp(self, cpid, instanceid, iface):
        self.logger.error('connect_interface_to_cp()', 'CP {} <->  {}:{}'.format(cpid, instanceid, iface))
        try:
            fdu = self.current_fdus.get(instanceid, None)
            if fdu is None:
                self.logger.error('connect_interface_to_cp()', 'LXD Plugin - FDU not exists')
                return {'error':404, 'error_msg': 'FDU {} not in runtime {}'.format(instanceid, self.uuid) }
            elif fdu.get_status() not in [State.CONFIGURED, State.RUNNING, State.PAUSED]:
                self.logger.error('connect_interface_to_cp()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
                return {'error':404, 'error_msg': 'FDU {} is not in correct state'.format(instanceid)}
            else:
                fdu_uuid = fdu.get_fdu_id()
                face = ''

                i = 0
                for intf in fdu.get_interfaces():
                    intf_name = intf.get('vintf_name')
                    if intf.get('virtual_interface').get('intf_type').upper() not in ['PHYSICAL','BRIDGED']:
                        intf_id = 'lxd-{}-{}'.format(fdu.get_short_id(), i)
                        if intf.get('name') == iface:
                            face = intf_id
                if face == '':
                    return {'error':404, 'error_msg': 'Unable to find interface {}'.format(iface)}
                r = self.nm.connect_interface_to_connection_point(face,cpid)
                self.logger.error('connect_interface_to_cp()', 'NM Returned {}'.format(r))
                return {'result':cpid}

        except Exception as e:
            import traceback
            self.logger.error('connect_interface_to_cp()', '[ERROR] {}'.format(traceback.format_exc()))
            traceback.format_exc()
            self.logger.error('connect_interface_to_cp()', '[ERROR] got error {}'.format(e))
            return {'error':503, 'error_msg':'{}'.format(e)}


    def disconnect_interface_from_cp(self, iface, instanceid):
        fdu = self.current_fdus.get(instanceid, None)
        if fdu is None:
            self.logger.error('disconnect_interface_from_cp()', 'LXD Plugin - FDU not exists')
            return {'error':404, 'error_msg': 'FDU {} not in runtime {}'.format(instanceid, self.uuid) }
        elif fdu.get_status() not in [State.CONFIGURED, State.RUNNING, State.PAUSED]:
            self.logger.error('disconnect_interface_from_cp()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            return {'error':404, 'error_msg': 'FDU {} is not in correct state'.format(instanceid)}
        else:
            fdu_uuid = fdu.get_fdu_id()
            face = ''

            i = 0
            for intf in fdu.get_interfaces():
                intf_name = intf.get('vintf_name')
                if intf.get('virtual_interface').get('intf_type').upper() not in ['PHYSICAL','BRIDGED']:
                    intf_id = 'lxd-{}-{}'.format(fdu.get_short_id(), i)
                    if intf.get('name') == iface:
                        face = intf_id
            if face == '':
                return {'error':404, 'error_msg': 'Unable to find interface {}'.format(iface)}
            r = self.nm.disconnect_interface(face)
            if r.get('result') is not None:
                return {'result':iface}
            return {'error':503, 'error_msg': 'Unable to disconnect interface {} to cp'.format(iface)}

    def __monitor_instance(self):
        self.logger.info('__monitor_instance()','[ INFO ] LXD Plugin - Staring monitoring of FDUs')
        while self.mon_run:
            time.sleep(self.update_interval)
            # (fdu_uuid, instance_uuid, fdu.name)
            for fdu_id, iid, name in self.mon_instances:
                try:
                    record = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_id, iid)
                    record = LXDFDU(record)
                    if record.get_status() not in ['LAND', 'TAKE_OFF','MIGRATE']:
                        self.logger.info('__monitor_instance()','[ INFO ] LXD Plugin - Updating status of {} - {}'.format(iid, name))
                        c = self.conn.containers.get(name)
                        cs = c.state()
                        detailed_state = {}

                        c_net = {}
                        for i in record.get_interfaces():
                            try:
                                ip = self.nm.get_address(i.get('mac_address',''))
                            except ValueError:
                                ip = ''
                            # Getting address from LXD if unable from network manager, eg. if connected to physical device/lxd bridge
                            if ip == '':
                                if cs.network is not None:
                                    lxd_net_info_addrs = cs.network[i['vintf_name']]['addresses']
                                    for a in lxd_net_info_addrs:
                                        if a['family'] == 'inet':
                                            ip = a['address']
                            c_net.update(
                                {
                                    i.get('vintf_name'):
                                    {
                                    'hwaddr': i.get('mac_address'),
                                    'addresses': [
                                        {'address': ip}
                                        ]
                                    }
                                }
                            )


                        detailed_state.update({'network': c_net})
                        detailed_state.update({'cpu': cs.cpu})
                        detailed_state.update({'memory': cs.memory})

                        record.set_hypervisor_info(detailed_state)
                        self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_id, iid, record.to_json())

                except Exception as e:
                    self.logger.error('__monitor_instance()', '[ ERROR ] LXD Plugin - Error on monitoring of Container uuid {} Error {}'.format(iid, e))
                    pass

    def __generate_custom_profile_userdata_configuration(self, userdata, config):
        config.update({'user.user-data': userdata})
        return config

    def __generate_custom_profile_devices_configuration(self, fdu):
        '''
        template = '[ {% for net in networks %}' \
                '{"eth{{loop.index -1 }}": ' \
                '{"name": "eth{{loop.index -1}}",' \
                '"type" : "nic",'  \
                '"parent": "{{ net.intf_name }}",' \
                '"nictype": "bridged" ,' \
                '"hwaddr" : {{ net.mac }} }"
                '{% endfor %} ]'
        '''
        devices = {}
        template_value_bridge = '{"name":"%s","type":"nic","parent":"%s","nictype":"bridged"}'
        template_value_phy = '{"name":"%s","type":"nic","parent":"%s","nictype":"physical"}'
        template_value_macvlan = '{"name":"%s","type":"nic","parent":"%s","nictype":"macvlan"}'

        template_vintf = '{"name":"%s","type":"nic","parent":"%s","nictype":"physical","hwaddr":"%s"}'
        template_value_phy_mac = '{"name":"%s","type":"nic","parent":"%s","nictype":"physical","hwaddr":"%s"}'
        template_value_macvlan_mac = '{"name":"%s","type":"nic","parent":"%s","nictype":"macvlan","hwaddr":"%s"}'
        template_value_bridge_mac = '{"name":"%s","type":"nic","parent":"%s","nictype":"bridged","hwaddr":"%s"}'
        '''
        # Create tenant's storage pool
        # TODO: allow more storage backends
        lxc storage create $TENANT dir

        # Add a root disk to the tenant's profile
        lxc profile device add $TENANT root disk path=/ pool=$TENANT

        '''

        template_disk = '{"path":"%s","type":"disk","pool":"%s", "size":"%sGB"}'

        i = 0
        interfaces = []
        for intf in fdu.get_interfaces():
            intf_name = intf.get('vintf_name')
            self.logger.info('__generate_custom_profile_devices_configuration()','Interface Info {}'.format(intf))

            if intf.get('virtual_interface').get('intf_type').upper() in ['PHYSICAL','BRIDGED']:
                # mac = intf.get('mac_address', self.__generate_random_mac())
                # intf.update({'mac_address': mac})
                real_intf_name = intf.get('phy_face', None)
                if real_intf_name is None:
                    raise ValueError("phy_face cannot be none")
                if self.os.get_intf_type(real_intf_name) in ['ethernet']:
                    mac = intf.get('mac_address', self.__generate_random_mac())
                    intf.update({'mac_address': mac})
                    nw_v = json.loads(str(template_value_macvlan_mac % (intf_name, real_intf_name, mac)))
                    self.os.set_interface_unaviable(real_intf_name)
                elif self.os.get_intf_type(real_intf_name) in ['wireless']:
                    nw_v = json.loads(str(template_value_phy % (intf_name, real_intf_name)))
                    self.os.set_interface_unaviable(real_intf_name)
                else:
                    mac = intf.get('mac_address', self.__generate_random_mac())
                    intf.update({'mac_address': mac})
                    nw_v = json.loads(str(template_value_bridge_mac % (intf_name, real_intf_name, mac)))
                interfaces.append(intf)
            else:
                mac = intf.get('mac_address', self.__generate_random_mac())
                intf.update({'mac_address': mac})
                intf_id = 'lxd-{}-{}'.format(fdu.get_short_id(), i)
                intf_data = self.nm.create_virtual_interface(intf_id, intf)
                self.logger.info('__generate_custom_profile_userdata_configuration()','LXD Plugin - Interface info {}'.format(intf_data))
                dev_name = intf_data.get('int_name')
                nw_v = json.loads(str(template_vintf % (intf_name, dev_name, mac)))
                interfaces.append(intf)
            devices.update({intf_name: nw_v})
            i += 1

        lxd_version = self.conn.host_info['environment']['server_version']
        if version.parse(lxd_version) >= version.parse('2.20'):
            st_n = 'root'
            st_v = json.loads(str(template_disk % ('/', self.lxd_storage_pool, int(fdu.get_computation_requirements().get('storage_size_gb')))))
            devices.update({st_n: st_v})
            # if fdu.storage is None or len(fdu.storage) == 0:
            #     st_n = 'root'
            #     st_v = json.loads(str(template_disk % ('/', self.lxd_storage_pool,)))
            #     devices.update({st_n: st_v})
            # else:
            #     for s in fdu.storage:
            #         st_n = s.get('name')
            #         st_v = json.loads(str(template_disk % (s.get('path'), s.get('pool'))))
            #         devices.update({st_n: st_v})

        # devices = Environment().from_string(template)
        # devices = devices.render(networks=entity.networks)
        # mid = {'machine-id': {'path': '/etc/machine-id', 'source': '/etc/machine-id', 'type': 'disk'}}
        # devices.update(mid)
        self.logger.info('__generate_custom_profile_devices_configuration()', 'LXD Plugin - Container Devices {}'.format(devices))
        return devices, interfaces

    def __generate_container_dict(self, fdu):
        # valid_host_name = fdu.name.replace('_','-')[:63]
        conf = {'name': fdu.name, 'profiles': fdu.profiles,
                'source': {'type': 'image', 'alias': fdu.image.get('uuid')}}
        self.logger.info('__generate_container_dict()', 'LXD Plugin - Container Configuration {}'.format(conf))
        return conf

    def __force_fdu_termination(self, fdu_uuid):
        self.logger.info('stop_fdu()', ' LXD Plugin - Stop a container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('stop_fdu()', 'LXD Plugin - FDU not exists')
        else:
            if fdu.get_status() == State.PAUSED:
                self.resume_fdu(fdu_uuid)
                self.stop_fdu(fdu_uuid)
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_status() == State.RUNNING:
                self.stop_fdu(fdu_uuid)
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_status() == State.CONFIGURED:
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_status() == State.DEFINED:
                self.undefine_fdu(fdu_uuid)

    def __get_bridge_names_from_instance_networks(self, instance_networks):
        return [network['br_name'] for network in instance_networks]

    # def __add_image(self, manifest):
    #     url = manifest.get('base_image')
    #     uuid = manifest.get('uuid')
    #     if url.startswith('http'):
    #         image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, url.split('/')[-1])
    #         self.agent.get_os_plugin().download_file(url, image_name)
    #     elif url.startswith('file://'):
    #         image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, url.split('/')[-1])
    #         cmd = 'cp {} {}'.format(url[len('file://'):], image_name)
    #         self.agent.get_os_plugin().execute_command(cmd, True)

    #     self.logger.info('__add_image()', '[ INFO ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, url)))
    #     image_data = self.agent.get_os_plugin().read_binary_file(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name))
    #     self.logger.info('__add_image()', '[ DONE ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, url)))
    #     img_info = {'url': url, 'path': image_name, 'uuid': uuid}

    #     self.logger.info('__add_image()', '[ INFO ] LXD Plugin - Creating image with alias {}'.format(uuid))
    #     img = self.conn.images.create(image_data, public=True, wait=True)
    #     img.add_alias(uuid, description=image_name)
    #     self.logger.info('__add_image()', '[ DONE ] LXD Plugin - Created image with alias {}'.format(uuid))
    #     self.images.update({uuid: img_info})
    #     manifest.update({'path': image_name})
    #     uri = '{}/{}'.format(self.HOME_IMAGE, manifest.get('uuid'))
    #     self.__update_actual_store(uri, manifest)

    # def __remove_image(self, image_uuid):
    #     image = self.images.get(image_uuid, None)
    #     if image is None:
    #         self.logger.info('__remove_image()', ' LXD Plugin - Image not found!!')
    #         return
    #     self.agent.get_os_plugin().remove_file(image.get('path'))
    #     self.images.pop(image_uuid)
    #     uri = '{}/{}'.format(self.HOME_IMAGE, image_uuid)
    #     self.__pop_actual_store(uri)

    # def __add_flavor(self, manifest):
    #     uri = '{}/{}'.format(self.HOME_FLAVOR, manifest.get('uuid'))
    #     self.__update_actual_store(uri, manifest)
    #     self.flavors.update({manifest.get('uuid'): manifest})

    # def __remove_flavor(self, flavor_uuid):
    #     self.flavors.pop(flavor_uuid)
    #     uri = '{}/{}'.format(self.HOME_FLAVOR, flavor_uuid)
    #     self.__pop_actual_store(uri)


    # TODO: add try catch for the exceptions
    def __fdu_observer(self, fdu_info):
        self.logger.info('__fdu_observer()', ' LXD Plugin - New Action of a FDU - FDU Info: {}'.format(fdu_info))
        action = fdu_info.get('status')
        fdu_uuid = fdu_info.get('uuid')
        react_func = self.__react(action)
        try:
            if action == 'UNDEFINE':
                self.logger.info('__fdu_observer()', ' LXD Plugin - This is a remove for : {}'.format(fdu_info))
                self.undefine_fdu(fdu_uuid)
            elif action == 'DEFINE':
                self.logger.info('__fdu_observer()', ' LXD Plugin - This is a define for : {}'.format(fdu_info))
                self.define_fdu(fdu_info)
            elif react_func is not None:
                react_func(fdu_uuid)
            else:
                self.logger.info('__fdu_observer()', ' LXD Plugin - Action not recognized : {}'.format(action))
        except FDUNotExistingException as nex:
            self.write_fdu_error(fdu_info.get('fdu_uuid'), fdu_uuid, 9, nex)
            time.sleep(10)
            self.connector.loc.actual.remove_node_fdu(self.node, self.uuid, fdu_info.get('fdu_uuid'), fdu_uuid)
            return
        except StateTransitionNotAllowedException as stna:
            self.write_fdu_error(fdu_info.get('fdu_uuid'), fdu_uuid, 10, stna)
            time.sleep(5)
            fdu = self.current_fdus.get(fdu_uuid)
            self.update_fdu_status(fdu_info.get('fdu_uuid'), fdu_uuid,fdu.status)
            return


    def __generate_random_mac(self):
        d = [ 0x00, 0x16,
            random.randint(0x00, 0x7f),
            random.randint(0x00, 0x7f),
            random.randint(0x00, 0xff),
            random.randint(0x00, 0xff) ]
        return ':'.join(map(lambda x: "%02x" % x, d))

    def __react(self, action):
        r = {
            'CONFIGURE': self.configure_fdu,
            'STOP': self.stop_fdu,
            'RESUME': self.resume_fdu,
            'RUN': self.run_fdu,
            'CLEAN': self.clean_fdu,
            'LAND': self.migrate_fdu,
            'TAKE_OFF': self.migrate_fdu
        }

        return r.get(action, None)


def read_file(file_path):
    data = ''
    with open(file_path, 'r') as f:
        data = f.read()
    return data


if __name__ == '__main__':
    if len(sys.argv) < 2:
        exit(-1)
    print('ARGS {}'.format(sys.argv))
    file_dir = os.path.dirname(__file__)
    manifest = json.loads(read_file(sys.argv[1]))
    na = LXD(manifest.get('name'), manifest.get('version'), manifest.get(
        'uuid'), manifest)
    na.start_runtime()