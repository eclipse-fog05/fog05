#!/usr/bin/env python3

# Copyright (c) 2014,2018 ADLINK Technology Inc.
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
# which is available at https://www.apache.org/licenses/LICENSE-2.0.
#
# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
#
# Contributors: Gabriele Baldoni, ADLINK Technology Inc. - Base plugins set


import sys
import os
import signal
import uuid
import json
import random
import time
import re
import threading
from packaging import version
from jinja2 import Environment
from pylxd import Client
from pylxd.exceptions import LXDAPIException
from mvar import MVar
from fog05 import Yaks_Connector
from fog05.DLogger import DLogger
from fog05.interfaces.States import State
from fog05.interfaces.RuntimePluginFDU import *
from LXDFDU import LXDFDU


class LXD(RuntimePluginFDU):

    def __init__(self, name, version, plugin_uuid, manifest):

        super(LXD, self).__init__(version, plugin_uuid)
        self.name = name
        loc = manifest.get('configuration').get('ylocator').split('/')[1]
        self.connector = Yaks_Connector(loc)
        self.logger = DLogger(debug_flag=True)
        self.node = manifest.get('configuration').get('nodeid')
        self.manifest = manifest
        self.configuration = manifest.get('configuration',{})
        self.pid = os.getpid()
        self.var = MVar()
        self.agent_conf = \
            self.connector.loc.actual.get_node_configuration(self.node)

        self.logger.info('__init__()', ' Hello from LXD Plugin')
        self.BASE_DIR = os.path.join(
            self.agent_conf.get('agent').get('path'),'lxd')
        self.DISK_DIR = 'disks'
        self.IMAGE_DIR = 'images'
        self.LOG_DIR = 'logs'

        file_dir = os.path.dirname(__file__)
        self.DIR = os.path.abspath(file_dir)
        self.conn = None
        self.images = {}
        self.flavors = {}
        self.mon_th = {}
        self.nm = self.get_nm_plugin().get('uuid')
        signal.signal(signal.SIGINT, self.__catch_signal)
        signal.signal(signal.SIGTERM, self.__catch_signal)

    def __catch_signal(self, signal, _):
        if signal in [2,15]:
            self.var.put(signal)

    def read_binary_file(self, file_path):
        data = None
        with open(file_path, 'rb') as f:
            data = f.read()
        return data

    def start_runtime(self):
        self.logger.info(
            'start_runtime()', ' LXD Plugin - Connecting to LXD')
        self.conn = Client()
        self.logger.info(
            'start_runtime()', '[ DONE ] LXD Plugin - Connecting to LXD')


        '''check if dirs exists if not exists create'''
        if self.call_os_plugin_function('dir_exists', {'dir_path': self.BASE_DIR}):
            if not self.call_os_plugin_function('dir_exists', {'dir_path': os.path.join(self.BASE_DIR, self.DISK_DIR)}):
                self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.DISK_DIR)})
            if not self.call_os_plugin_function('dir_exists', {'dir_path': os.path.join(self.BASE_DIR, self.IMAGE_DIR)}):
                self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.IMAGE_DIR)})
            if not self.call_os_plugin_function('dir_exists', {'dir_path': os.path.join(self.BASE_DIR, self.LOG_DIR)}):
                self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.LOG_DIR)})
        else:
            self.call_os_plugin_function(
                'create_dir', {'dir_path': os.path.join(self.BASE_DIR)})
            self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.DISK_DIR)})
            self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.IMAGE_DIR)})
            self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.LOG_DIR)})


        self.connector.loc.desired.observe_node_runtime_fdus(self.node, self.uuid, self.__fdu_observer)

        self.manifest.update({'pid': self.pid})
        self.manifest.update({'status': 'running'})
        self.connector.loc.actual.add_node_plugin(self.node, self.uuid, self.manifest)

        self.logger.info('start_runtime()', ' LXD Plugin - Started...')

        r = self.var.get()
        self.stop_runtime()
        self.connector.close()
        exit(0)

        return self.uuid

    def stop_runtime(self):
        self.logger.info(
            'stopRuntime()', 'LXD Plugin - Destroying {} running FDUs'.format(len(self.current_fdus)))
        for k in list(self.current_fdus.keys()):
            fdu = self.current_fdus.get(k)
            self.__force_fdu_termination(k)
            if fdu.get_state() == State.DEFINED:
                self.undefine_fdu(k)
        keys = list(self.images.keys())
        for k in keys:
            self.logger.info(
                'stopRuntime()', 'Removing Image {}'.format(k))
            try:
                img = self.conn.images.get_by_alias(k)
                img.delete()
            except LXDAPIException as e:
                self.logger.error('stopRuntime()', 'Error {}'.format(e))
                pass

        self.conn = None
        self.logger.info(
            'stopRuntime()', '[ DONE ] LXD Plugin - Bye Bye')

    def get_fdus(self):
        return self.current_fdus

    def define_fdu(self, fdu_manifest):
        self.logger.info(
            'define_fdu()', ' LXD Plugin - Defining a Container')

        fdu_uuid = fdu_manifest.get('uuid')
        fdu = LXDFDU.from_descriptor(fdu_manifest)

        if self.is_uuid(fdu.get_image_uri()):
            img_info = self.images.get(fdu.get_image_uri(), None)
            if img_info is None:
                self.logger.error(
                    'define_fdu()', '[ ERRO ] LXD Plugin - Cannot find image {}'.format(fdu.get_image_uri()))
                # self.__write_error_entity(fdu_uuid, 'Image not found!')

            fdu.image.update({'file':img_info.get('base_image')})
            fdu.image.update({'uuid':img_info.get('uuid')})

        else:
            if fdu.get_image_uri().startswith('http'):
                image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])
                self.call_os_plugin_function('download_file',{'url':fdu.get_image_uri(),'file_path':image_name})
            elif fdu.get_image_uri().startswith('file://'):
                image_name = os.path.join(
                    self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])
                cmd = 'cp {} {}'.format(fdu.get_image_uri()[len('file://'):], image_name)
                self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})

            # TODO verify IMAGE CHECKSUM

            self.logger.info('define_fdu()', '[ INFO ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name)))

            # TODO: this should some how pass through YAKS, at this time the LXD plugin will read
            # the file from the disk
            # self.call_os_plugin_function('execute_command',{'file_path':os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name)})
            image_data = self.read_binary_file(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name))

            self.logger.info('define_fdu()', '[ DONE ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name)))
            img_info = {}
            try:
                self.logger.info(
                    'define_fdu()', '[ INFO ] LXD Plugin - Creating image with alias {}'.format(fdu_uuid))
                try:
                    img = self.conn.images.create(image_data, public=True, wait=True)
                    img.add_alias(fdu_uuid, description=fdu.name)
                except LXDAPIException as e:
                    # TODO: check this error with errno
                    if '{}'.format(e) == 'Image with same fingerprint already exists':
                        self.logger.info('define_fdu()', '[ INFO ] LXD Plugin - Image with same fingerprint already exists')
                        pass

                self.logger.info(
                    'define_fdu()', '[ DONE ] LXD Plugin - Created image with alias {}'.format(fdu_uuid))
                img_info = {}
                img_info.update({'uuid': fdu_uuid})
                img_info.update({'name': '{}_img'.format(fdu.name)})
                img_info.update({'base_image': image_name})
                img_info.update({'type': 'lxd'})
                img_info.update({'format': fdu.get_image_format()})

                fdu.image.update({'file': image_name})
                fdu.image.update({'uuid': fdu_uuid})

                self.images.update({fdu_uuid: img_info})
                self.connector.loc.actual.add_node_image(self.node, self.uuid, fdu_uuid, img_info)

            except LXDAPIException as e:
                self.logger.error('define_fdu()', 'Error {}'.format(e))
                self.current_fdus.update({fdu_uuid: fdu})
                lxd_info = self.connector.loc.desired.get_node_fdu(self.node, self.uuid, fdu_uuid)
                lxd_info.update({'status': 'error'})
                lxd_info.update({'error': '{}'.format(e)})
                self.current_fdus.update({fdu_uuid: fdu})
                self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, lxd_info)
                self.logger.info('define_fdu()', '[ ERRO ] LXD Plugin - Container uuid: {}'.format(fdu_uuid))



        fdu.set_state(State.DEFINED)
        # if fdudata.get('devices'):
        #     fdu.devices = json.loads(fdudata.get('devices'))
        self.current_fdus.update({fdu_uuid: fdu})
        lxd_info = self.connector.loc.desired.get_node_fdu(self.node, self.uuid, fdu_uuid)
        lxd_info.update({'status': 'defined'})
        self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, lxd_info)
        self.logger.info('define_fdu()', '[ DONE ] LXD Plugin - Container uuid: {}'.format(lxd_info))



    def undefine_fdu(self, fdu_uuid):

        self.logger.info('undefine_fdu()', ' LXD Plugin - Undefine a Container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('undefine_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.DEFINED:
            self.logger.error('undefine_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in DEFINED state',
                                                     'FDU {} is not in DEFINED state'.format(fdu_uuid))
        else:
            try:

                c = self.conn.containers.get(fdu.name)
                c.delete()

                time.sleep(2)
                profile = self.conn.profiles.get(fdu_uuid)
                profile.sync()
                while True:
                    if len(profile.used_by) == 0:
                        break
                    profile.sync()
                    time.sleep(1)
                profile.delete()

                img = self.conn.images.get_by_alias(fdu_uuid)
                img.delete()
                self.images.pop

            except Exception as e:
                        self.logger.info('undefine_fdu()', '[ ERRO ] LXD Plugin - Undefine a Container Exception raised {}'.format(e))


            self.current_fdus.pop(fdu_uuid, None)
            self.connector.loc.actual.remove_node_fdu(self.node, self.uuid, fdu_uuid)
            self.logger.info('undefine_fdu()', '[ DONE ] LXD Plugin - Undefine a Container uuid {}'.format(fdu_uuid))
            return True

    def configure_fdu(self, fdu_uuid):

        self.logger.info('configure_fdu()', ' LXD Plugin - Configure a Container uuid {} '.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('configure_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.DEFINED:
            self.logger.error('configure_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in DEFINED state',
                                                     'FDU {} is not in DEFINED state'.format(fdu_uuid))
        else:

            self.logger.info('configure_fdu()', '[ INFO ] LXD Plugin - Creating profile...')
            try:

                custom_profile_for_fdu = self.conn.profiles.create(fdu_uuid)


                if fdu.configuration is not None:
                    if fdu.configuration.get('conf_type') in ['CLOUD_INIT']:
                        c_init_file = fdu.configuration.get('cloud_init')
                        user_data = self.__generate_custom_profile_userdata_configuration(fdu.c_init_file)
                        custom_profile_for_fdu.config = user_data

                conf = {'environment.FOSUUID': fdu_uuid,
                        'environment.FOSNODEUUID': self.node
                        }
                for cp in fdu.get_connection_points():
                    cp_id = cp.get('uuid')
                    cp.update({'status':'add'})
                    self.connector.loc.desired.add_node_port(self.node, self.nm, cp_id,cp)
                    res = self.connector.loc.actual.get_node_port(self.node, self.nm, cp_id)
                    while res is None:
                        res = self.connector.loc.actual.get_node_port(self.node, self.nm, cp_id)
                dev = self.__generate_custom_profile_devices_configuration(fdu)
                self.logger.info('configure_fdu()', '[ INFO ] Profile devices {}'.format(dev))
                # if fdu.devices:
                #     for d in fdu.devices:
                #         dev.update(d)
                self.logger.info('__generate_custom_profile_devices_configuration()', 'LXD Plugin - Devices {}'.format(dev))
                custom_profile_for_fdu.config = conf
                custom_profile_for_fdu.devices = dev
                custom_profile_for_fdu.save()

            except LXDAPIException as e:
                self.logger.error('configure_fdu()', 'Error {}'.format(e))
                pass
            self.logger.info('configure_fdu()', '[ DONE ] LXD Plugin - Creating profile...')
            if fdu.profiles is None:
                fdu.profiles = list()

            fdu.profiles.append(fdu_uuid)

            self.logger.info('configure_fdu()', '[ INFO ] LXD Plugin - Generating container configuration...')
            config = self.__generate_container_dict(fdu)
            self.logger.info('configure_fdu()', '[ DONE ] LXD Plugin - Generating container configuration...')

            self.logger.info('configure_fdu()', '[ INFO ] LXD Plugin - Creating Container...')
            self.conn.containers.create(config, wait=True)
            self.logger.info('configure_fdu()', '[ DONE ] LXD Plugin - Creating Container...')

            fdu.on_configured(config)

            self.current_fdus.update({fdu_uuid: fdu})

            container_info =self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            container_info.update({'status': 'configured'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid,container_info)

            self.logger.info('configure_fdu()', '[ DONE ] LXD Plugin - Configure a Container uuid {}'.format(fdu_uuid))

    def clean_fdu(self, fdu_uuid):

        self.logger.info('clean_fdu()', ' LXD Plugin - Clean a Container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('clean_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.CONFIGURED:
            self.logger.error('clean_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in CONFIGURED state',
                                                     'FDU {} is not in CONFIGURED state'.format(fdu_uuid))
        else:

            fdu.on_clean()


            for intf in fdu.get_interfaces():
                intf_name = intf.get('name')
                intf_id = 'lxd-{}-{}'.format(fdu.name, intf_name)
                self.call_nw_plugin_function('delete_virtual_interface',{'intf_id':intf_id})
            for cp in fdu.get_connection_points():
                cp_id = cp.get('uuid')
                cp = self.connector.loc.actual.get_node_port(self.node, self.nm, cp_id)
                cp.update({'status':'remove'})
                self.connector.loc.desired.add_node_port(self.node, self.nm, cp_id, cp)
            self.current_fdus.update({fdu_uuid: fdu})
            lxd_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            lxd_info.update({'status': 'defined'})
            # TODO: this should be an update when YAKS will implement update
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, lxd_info)
            self.logger.info('clean_fdu()', '[ DONE ] LXD Plugin - Clean a Container uuid {} '.format(fdu_uuid))

            return True

    def run_fdu(self, fdu_uuid):
        self.logger.info('run_fdu()', ' LXD Plugin - Starting a Container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu_uuid is None:
            self.logger.error('run_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.CONFIGURED:
            self.logger.error('run_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in CONFIGURED state',
                                                     'FDU {} is not in CONFIGURED state'.format(fdu_uuid))
        else:
            container_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            container_info.update({'status': 'starting'})
            self.current_fdus.update({fdu_uuid: fdu})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, container_info)

            c = self.conn.containers.get(fdu.name)
            c.start()
            while c.status != 'Running':
                try:
                    c.sync()
                except Exception as e:
                    self.logger.info('run_fdu()', '[ ERR ] LXD Plugin - {}'.format(e))
                    pass

            fm = c.FilesManager(self.conn, c)
            envs = 'export FOSUUID={} \n' \
                   'export FOSNODEUUID={}'\
                .format(fdu_uuid, self.node)
            fm.put('/etc/profile.d/99-fos', envs, mode="0644")
            fdu.on_start()

            container_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            container_info.update({'status': 'run'})
            self.current_fdus.update({fdu_uuid: fdu})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, container_info)
            self.logger.info('run_fdu()', '[ DONE ] LXD Plugin - Starting a Container uuid {}'.format(fdu_uuid))

            # TODO: monitoring TBD
            # mt = threading.Thread(target=self.__monitor_instance, args=(fdu_uuid, instance.name),daemon=True)
            # mt.start()
            # self.mon_th.update({fdu_uuid:mt})
            # self.logger.info('run_fdu()', '[ DONE ] LXD Plugin - Starting a Monitoring of {}'.format(fdu_uuid))

    def stop_fdu(self, fdu_uuid):
        self.logger.info('stop_fdu()', ' LXD Plugin - Stop a Container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('stop_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.RUNNING:
            self.logger.error('stop_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in RUNNING state',
                                                     'FDU {} is not in RUNNING state'.format(fdu_uuid))
        else:

            c = self.conn.containers.get(fdu.name)
            # self.mon_th.pop(fdu_uuid)
            c.stop(force=False, wait=True)
            c.sync()

            while c.status != 'Stopped':
                c.sync()

            fdu.on_stop()
            self.current_fdus.update({fdu_uuid: fdu})

            container_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            container_info.update({'status': 'stop'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, container_info)
            self.logger.info('stop_fdu()', '[ DONE ] LXD Plugin - Stop a Container uuid {}'.format(fdu_uuid))

    def pause_fdu(self, fdu_uuid):
        self.logger.info('pause_fdu()', ' LXD Plugin - Pause a Container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('pause_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.RUNNING:
            self.logger.error('pause_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in RUNNING state',
                                                     'FDU {} is not in RUNNING state'.format(fdu_uuid))
        else:

            c = self.conn.containers.get(fdu.name)
            c.freeze()

            fdu.on_pause()
            self.current_fdus.update({fdu_uuid: fdu})
            container_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            container_info.update({'status': 'pause'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, container_info)
            self.logger.info('pause_fdu()', '[ DONE ] LXD Plugin - Pause a Container uuid {}'.format(fdu_uuid))

    def resume_fdu(self, fdu_uuid):
        self.logger.info('resume_fdu()', ' LXD Plugin - Resume a Container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('resume_fdu()', 'LXD Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing',
                                             'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.PAUSED:
            self.logger.error('resume_fdu()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in PAUSED state',
                                                     'FDU {} is not in PAUSED state'.format(fdu_uuid))
        else:
            c = self.conn.containers.get(fdu.name)
            c.unfreeze()

            fdu.on_resume()
            self.current_fdus.update({fdu_uuid: fdu})

            container_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            container_info.update({'status': 'run'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, container_info)
            self.logger.info('resume_fdu()', '[ DONE ] LXD Plugin - Resume a Container uuid {}'.format(fdu_uuid))


    def migrate_fdu(self, fdu_uuid, dst=False):
        raise NotImplementedError("TBD")
        # if type(entity_uuid) == dict:
        #     entity_uuid = entity_uuid.get('entity_uuid')
        # self.logger.info('migrate_entity()', ' LXD Plugin - Migrate a container uuid {}'.format(entity_uuid))
        # entity = self.current_fdus.get(entity_uuid, None)
        # if entity is None or entity.get_instance(instance_uuid) is None:
        #     if dst is True:
        #         self.logger.info('migrate_entity()', ' LXD Plugin - I\'m the Destination Node')
        #         self.before_migrate_entity_actions(entity_uuid, True, instance_uuid)

        #         uri_instance = '{}/{}/{}/{}/{}'.format(self.agent.dhome, self.HOME_ENTITY, entity_uuid, self.INSTANCE, instance_uuid)
        #         instance_info = json.loads(self.agent.dstore.get(uri_instance))

        #         while True:
        #             try:
        #                 c = self.conn.containers.get(instance_info.get('name'))
        #                 if c.status.upper() == 'running'.upper():
        #                     break
        #                 else:
        #                     self.logger.info('migrate_entity()', ' LXD Plugin - Container in this host but not running')
        #             except Exception as e:
        #                 self.logger.info('migrate_entity()', ' LXD Plugin - Container not already in this host')
        #             time.sleep(2)

        #         self.after_migrate_entity_actions(entity_uuid, True, instance_uuid)
        #         self.logger.info('migrate_entity()', '[ DONE ] LXD Plugin - Migrate a Container uuid {}'.format(entity_uuid))
        #         return True

        #     else:
        #         self.logger.error('migrate_entity()', 'LXD Plugin - FDU not exists')
        #         raise FDUNotExistingException('FDU not existing',
        #                                          'FDU {} not in runtime {}'.format(entity_uuid, self.uuid))
        # elif entity.get_state() != State.DEFINED:
        #     self.logger.error('migrate_entity()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
        #     raise StateTransitionNotAllowedException('FDU is not in DEFINED state',
        #                                              'FDU {} is not in DEFINED state'.format(entity_uuid))
        # else:

        #     instance = entity.get_instance(instance_uuid)
        #     if instance.get_state() not in [State.RUNNING, State.TAKING_OFF]:
        #         self.logger.error('clean_fdu()', 'LXD Plugin - Instance state is wrong, or transition not allowed')
        #         # self.__write_error_instance(entity_uuid, instance_uuid, 'FDU Instance not exist')
        #         raise StateTransitionNotAllowedException('Instance is not in RUNNING state', 'Instance {} is not in RUNNING state'.format(entity_uuid))

        #     self.logger.info('migrate_entity()', ' LXD Plugin - I\'m the Source Node')
        #     res = self.before_migrate_entity_actions(entity_uuid, instance_uuid=instance_uuid)
        #     if not res:
        #         self.logger.error('migrate_entity()', ' LXD Plugin - Error source node before migration, aborting')
        #         # self.__write_error_instance(entity_uuid, instance_uuid, 'FDU Instance migration error on source')
        #         return

        #     self.before_migrate_entity_actions(entity_uuid, False, instance_uuid)

        #     uri_instance = '{}/{}/{}/{}/{}'.format(self.agent.dhome, self.HOME_ENTITY, entity_uuid, self.INSTANCE, instance_uuid)
        #     instance_info = json.loads(self.agent.dstore.get(uri_instance))
        #     name = instance_info.get('entity_data').get('name')
        #     # destination node uuid
        #     destination_node_uuid = instance_info.get('dst')
        #     uri = '{}/{}'.format(self.agent.aroot, destination_node_uuid)

        #     while True:
        #         dst_node_info = self.agent.astore.get(uri)  # TODO: solve this ASAP
        #         if dst_node_info is not None:
        #             if isinstance(dst_node_info, tuple):
        #                 dst_node_info = dst_node_info[0]
        #             dst_node_info = dst_node_info.replace("'", '"')
        #             break

        #     while True:
        #         luri = self.agent.ahome
        #         local_node_info = self.agent.astore.get(luri)  # TODO: solve this ASAP
        #         if local_node_info is not None:
        #             if isinstance(local_node_info, tuple):
        #                 local_node_info = local_node_info[0]
        #             local_node_info = local_node_info.replace("'", '"')
        #             break
        #     # print(dst_node_info)
        #     dst_node_info = json.loads(dst_node_info)
        #     local_node_info = json.loads(local_node_info)

        #     nw = dst_node_info.get('network')
        #     dst_hostname = dst_node_info.get('name')
        #     dst_ip = [x for x in nw if x.get('default_gw') is True]
        #     # TODO: or x.get('inft_configuration').get('ipv6_gateway') for ip_v6
        #     if len(dst_ip) == 0:
        #         return False

        #     nw_local = local_node_info.get('network')
        #     local_ip = [x for x in nw_local if x.get('default_gw') is True]
        #     if len(local_ip) == 0:
        #         return False

        #     dst_ip = dst_ip[0].get('inft_configuration').get('ipv4_address')  # TODO: as on search should use ipv6
        #     local_ip = local_ip[0].get('inft_configuration').get('ipv4_address')  # TODO: as on search should use ipv6

        #     path_cert = os.path.join(self.DIR, 'templates', 'lxd.crt')
        #     path_key = os.path.join(self.DIR, 'templates', 'lxd.key')

        #     remote_client = Client(endpoint='https://{}:8443'.format(dst_ip), cert=(path_cert, path_key), verify=False)
        #     local_client = Client(endpoint='https://{}:8443'.format(local_ip), cert=(path_cert, path_key), verify=False)

        #     # remote_client = Client(endpoint='https://{}:8443'.format(dst_ip), verify=False)
        #     # local_client = Client(endpoint='https://{}:8443'.format(local_ip), verify=False)

        #     remote_client.authenticate('fog')
        #     local_client.authenticate('fog')

        #     cont = local_client.containers.get(instance_info.get('name'))

        #     try:
        #         cont.migrate(remote_client, wait=True)
        #     except LXDAPIException as e:
        #         self.logger.info('migrate_entity()', ' LXD Plugin - LXD error {}'.format(e))
        #         cont.delete()
        #     instance.on_stop()

        #     self.current_fdus.update({entity_uuid: entity})
        #    self.after_migrate_entity_actions(entity_uuid, False, instance_uuid)

    def before_migrate_entity_actions(self, fdu_uuid, dst=False):
        raise NotImplementedError("TBD")
        # if dst is True:
        #     self.logger.info('before_migrate_entity_actions()', ' LXD Plugin - Before Migration Destination')
        #     uri = '{}/{}/{}/{}/{}'.format(self.agent.dhome, self.HOME_ENTITY, entity_uuid, self.INSTANCE, instance_uuid)
        #     instance_info = json.loads(self.agent.dstore.get(uri))
        #     lxc_info = instance_info.get('entity_data')

        #     self.logger.info('before_migrate_entity_actions()', ' LXD Plugin - Waiting image')
        #     while True:
        #         base_image = lxc_info.get('base_image')
        #         if base_image in self.images.keys():
        #             break

        #     self.logger.info('before_migrate_entity_actions()', ' LXD Plugin - Waiting entity')
        #     while True:
        #         if entity_uuid in self.current_fdus.keys():
        #             break
        #     self.logger.info('before_migrate_entity_actions()', ' FDU {} defined!!!'.format(entity_uuid))

        #     img_info = self.images.get(base_image)
        #     entity = self.current_fdus.get(entity_uuid)

        #     name = lxc_info.get('name')
        #     # disk_path = '{}.{}'.format(instance_uuid, img_info.get('format'))
        #     # cdrom_path = '{}_config.iso'.format(instance_uuid)
        #     # disk_path = os.path.join(self.BASE_DIR, self.DISK_DIR, disk_path)
        #     # cdrom_path = os.path.join(self.BASE_DIR, self.DISK_DIR, cdrom_path)

        #     instance = LXDFDUInstance(instance_uuid, name, entity.networks, entity.image,
        #                                  entity.user_file, entity.ssh_key, entity.storage, entity.profiles,
        #                                  entity_uuid)

        #     instance.state = State.LANDING
        #     lxc_info.update({'name': name})

        #     instance_info.update({'entity_data': lxc_info})
        #     instance_info.update({'status': 'landing'})

        #     entity.add_instance(instance)
        #     self.current_fdus.update({entity_uuid: entity})

        #     self.__update_actual_store_instance(entity_uuid, instance_uuid, instance_info)

        #     return True

        # else:
        #     self.logger.info('before_migrate_entity_actions()', ' LXD Plugin - Before Migration Source: get information about destination node')

        #     local_var = MVar()
        #     def cb(key, value, v):
        #         local_var.put(value)


        #     entity = self.current_fdus.get(entity_uuid, None)
        #     instance = entity.get_instance(instance_uuid)

        #     uri_entity = '{}/{}/{}'.format(self.agent.ahome, self.HOME_ENTITY, entity_uuid)
        #     entity_info = json.loads(self.agent.astore.get(uri_entity))
        #     entity_info.update({'status': 'define'})

        #     # reading instance info
        #     uri_instance = '{}/{}/{}/{}/{}'.format(self.agent.dhome, self.HOME_ENTITY, entity_uuid, self.INSTANCE, instance_uuid)
        #     instance_info = json.loads(self.agent.dstore.get(uri_instance))
        #     lxc_info = instance_info.get('entity_data')
        #     # destination node uuid
        #     destination_node_uuid = instance_info.get('dst')

        #     # flavor and image information
        #     flavor_info = self.flavors.get(lxc_info.get('flavor_id'))
        #     img_info = self.images.get(lxc_info.get('base_image'))

        #     # getting same plugin in destination node
        #     uri = '{}/{}/plugins'.format(self.agent.aroot, destination_node_uuid)
        #     all_plugins = json.loads(self.agent.astore.get(uri)).get('plugins')  # TODO: solve this ASAP

        #     runtimes = [x for x in all_plugins if x.get('type') == 'runtime']
        #     search = [x for x in runtimes if 'LXD' in x.get('name')]
        #     if len(search) == 0:
        #         self.logger.error('before_migrate_entity_actions()', 'LXD Plugin - Before Migration Source: No LXD Plugin, Aborting!!!')
        #         # self.__write_error_instance(entity_uuid, instance_uuid, 'FDU Instance Migration error')
        #         return False
        #     else:
        #         lxd_uuid = search[0].get('uuid')

        #     # self.logger.info('before_migrate_entity_actions()', 'LXD Plugin - check if image is present on destination')
        #     # uri_img = '{}/{}/runtime/{}/image/{}'.format(self.agent.aroot, destination_node_uuid, lxd_uuid, img_info)
        #     # if self.agent.astore.get(uri_img) is None:
        #     #     self.logger.info('before_migrate_entity_actions()', 'LXD Plugin - sending image to destination')
        #     #     uri_img = '{}/{}/runtime/{}/image/{}'.format(self.agent.droot, destination_node_uuid, lxd_uuid, img_info)
        #     #     self.agent.dstore.put(uri_img, json.dumps(img_info))

        #     self.logger.info('before_migrate_entity_actions()', 'LXD Plugin - check if entity is present on destination')
        #     uri_entity = '{}/{}/runtime/{}/entity/{}'.format(self.agent.aroot, destination_node_uuid, lxd_uuid, entity_uuid)
        #     if self.agent.astore.get(uri_entity) is None:
        #         self.logger.info('before_migrate_entity_actions()', 'LXD Plugin - sending entity to destination')
        #         uri_entity = '{}/{}/runtime/{}/entity/{}'.format(self.agent.droot, destination_node_uuid, lxd_uuid, entity_uuid)
        #         self.agent.dstore.put(uri_entity, json.dumps(entity_info))
        #         self.logger.info('before_migrate_entity_actions()', 'LXD Plugin - Waiting entity in destination')


        #         uri_entity = '{}/{}/runtime/{}/entity/{}'.format(self.agent.aroot, destination_node_uuid, lxd_uuid, entity_uuid)
        #         subid = self.agent.astore.observe(uri_entity, cb)
        #         entity_info = json.loads(local_var.get())
        #         es = entity_info.get('status')
        #         while es not in ['defined','error']:
        #             entity_info = json.loads(local_var.get())
        #             es = entity_info.get('status')
        #         self.agent.astore.overlook(subid)
        #         self.logger.info('before_migrate_entity_actions()', 'LXD Plugin - FDU in destination!')

        #         # while True:
        #         #     uri_entity = '{}/{}/runtime/{}/entity/{}'.format(self.agent.aroot, destination_node_uuid, lxd_uuid, entity_uuid)
        #         #     jdata = self.agent.astore.get(uri_entity)
        #         #     # print('{}'.format(jdata))
        #         #     if jdata is not None:
        #         #         self.logger.info('before_migrate_entity_actions()', 'LXD Plugin - FDU in destination!')
        #         #         entity_info = json.loads(jdata)
        #         #         if entity_info is not None and entity_info.get('status') == 'defined':
        #         #             break

        #     self.logger.info('before_migrate_entity_actions()', ' LXD Plugin - Before Migration Source: Waiting destination to be ready')
        #     uri = '{}/{}/runtime/{}/entity/{}/instance/{}'.format(self.agent.aroot, destination_node_uuid, lxd_uuid, entity_uuid, instance_uuid)
        #     subid = self.agent.astore.observe(uri, cb)
        #     self.logger.info('before_migrate_entity_actions()', 'KVM Plugin - FDU in destination!')
        #     entity_info = json.loads(local_var.get())
        #     es = entity_info.get('status')
        #     while es not in ['landing','error']:
        #         entity_info = json.loads(local_var.get())
        #         es = entity_info.get('status')
        #     self.agent.astore.overlook(subid)
        #     # while True:
        #     #     # self.logger.info('before_migrate_entity_actions()', ' LXD Plugin - Before Migration Source: Waiting destination to be ready')
        #     #     uri = '{}/{}/runtime/{}/entity/{}/instance/{}'.format(self.agent.aroot, destination_node_uuid, lxd_uuid, entity_uuid, instance_uuid)
        #     #     lxc_info = self.agent.astore.get(uri)
        #     #     if lxc_info is not None:
        #     #         lxc_info = json.loads(lxc_info)
        #     #         if lxc_info is not None and lxc_info.get('status') == 'landing':
        #     #             break
        #     self.logger.info('before_migrate_entity_actions()', ' LXD Plugin - Before Migration Source: Destination is ready!')

        #     instance.state = State.TAKING_OFF
        #     instance_info.update({'status': 'taking_off'})
        #     self.__update_actual_store_instance(entity_uuid, instance_uuid, instance_info)
        #     self.current_fdus.update({entity_uuid: entity})
        #     return True

    def after_migrate_entity_actions(self, fdu_uuid, dst=False):
        raise NotImplementedError("TBD")
        # if type(entity_uuid) == dict:
        #     entity_uuid = entity_uuid.get('entity_uuid')
        # entity = self.current_fdus.get(entity_uuid, None)
        # if entity is None:
        #     self.logger.error('after_migrate_entity_actions()', 'LXD Plugin - FDU not exists')
        #     raise FDUNotExistingException('FDU not existing',
        #                                      'FDU {} not in runtime {}'.format(entity_uuid, self.uuid))
        # elif entity.get_state() != State.DEFINED:
        #     self.logger.error('after_migrate_entity_actions()', 'LXD Plugin - FDU state is wrong, or transition not allowed')
        #     raise StateTransitionNotAllowedException('FDU is not in correct state',
        #                                              'FDU {} is not in correct state'.format(entity.get_state()))
        # else:
        #     if dst is True:
        #         '''
        #         Here the plugin also update to the current status, and remove unused keys
        #         '''
        #         instance = entity.get_instance(instance_uuid)
        #         '''
        #         Here the plugin also update to the current status, and remove unused keys
        #         '''
        #         self.logger.info('after_migrate_entity_actions()', ' LXD Plugin - After Migration Destination: Updating state')
        #         instance.on_start()
        #         self.current_fdus.update({entity_uuid: entity})

        #         uri = '{}/{}/{}/{}/{}'.format(self.agent.dhome, self.HOME_ENTITY, entity_uuid, self.INSTANCE, instance_uuid)
        #         lxc_info = json.loads(self.agent.dstore.get(uri))
        #         lxc_info.pop('dst')
        #         lxc_info.update({'status': 'run'})

        #         self.__update_actual_store_instance(entity_uuid, instance_uuid, lxc_info)
        #         self.current_fdus.update({entity_uuid: entity})

        #         return True
        #     else:
        #         '''
        #         Source node destroys all information about vm
        #         '''
        #         self.logger.info('afterMigrateFDUActions()', ' LXD Plugin - After Migration Source: Updating state, destroy container')
        #         self.__force_entity_instance_termination(entity_uuid, instance_uuid)
        #         return True

    def __generate_custom_profile_userdata_configuration(self, userdata):
        userdata = {'user.user-data': userdata}
        return userdata

    def __generate_custom_profile_devices_configuration(self, fdu):
        '''
        template = '[ {% for net in networks %}' \
                '{"eth{{loop.index -1 }}": ' \
                '{"name": "eth{{loop.index -1}}",' \
                '"type" : "nic",'  \
                '"parent": "{{ net.intf_name }}",' \
                '"nictype": "bridged" ,' \
                '"hwaddr" : {{ net.mac }} }"
                '{% endfor %} ]'
        '''
        devices = {}
        template_value_bridge = '{"name":"%s","type":"nic","parent":"%s","nictype":"bridged"}'
        template_value_phy = '{"name":"%s","type":"nic","parent":"%s","nictype":"physical"}'
        template_value_macvlan = '{"name":"%s","type":"nic","parent":"%s","nictype":"macvlan"}'

        template_vintf = '{"name":"%s","type":"nic","parent":"%s","nictype":"physical","hwaddr":"%s"}'
        template_value_phy_mac = '{"name":"%s","type":"nic","parent":"%s","nictype":"physical","hwaddr":"%s"}'
        template_value_macvlan_mac = '{"name":"%s","type":"nic","parent":"%s","nictype":"macvlan",,"hwaddr":"%s"}'
        template_value_bridge_mac = '{"name":"%s","type":"nic","parent":"%s","nictype":"bridged","hwaddr":"%s"}'
        '''
        # Create tenant's storage pool
        # TODO: allow more storage backends
        lxc storage create $TENANT dir

        # Add a root disk to the tenant's profile
        lxc profile device add $TENANT root disk path=/ pool=$TENANT

        '''

        template_disk = '{"path":"%s","type":"disk","pool":"%s"}'


        for intf in fdu.get_interfaces():
            intf_name = intf.get('name')
            mac = intf.get('mac_address')
            if intf.get('virtual_interface').get('intf_type').upper() in ['PHYSICAL','BRIDGED']:
                real_intf_name = intf.get('virtual_interface').get('vpci')
                if self.call_os_plugin_function('get_intf_type', {'name': real_intf_name}) in ['ethernet']:
                    nw_v = json.loads(str(template_value_macvlan_mac % (intf_name, real_intf_name, mac)))
                    self.call_os_plugin_function('set_interface_unaviable', {'intf_name': real_intf_name})
                elif self.call_os_plugin_function('get_intf_type', {'name': real_intf_name}) in ['wireless']:
                    nw_v = json.loads(str(template_value_phy_mac % (intf_name, real_intf_name, mac)))
                    self.call_os_plugin_function('set_interface_unaviable', {'intf_name': real_intf_name})
                else:
                    nw_v = json.loads(str(template_value_bridge_mac % (intf_name, real_intf_name, mac)))
            else:
                intf_id = 'lxd-{}-{}'.format(fdu.name, intf_name)
                intf_data = self.call_nw_plugin_function('create_virtual_interface', {'intf_id':intf_id, 'descriptor': intf})
                self.logger.info('__generate_custom_profile_userdata_configuration()','LXD Plugin - Interface info {}'.format(intf_data))
                dev_name = intf_data.get('int_name')
                nw_v = json.loads(str(template_vintf % (intf_name, dev_name, mac)))
            devices.update({intf_name: nw_v})

        lxd_version = self.conn.host_info['environment']['server_version']
        if version.parse(lxd_version) >= version.parse('2.20'):
            st_n = 'root'
            st_v = json.loads(str(template_disk % ('/', 'default')))
            devices.update({st_n: st_v})
            # if fdu.storage is None or len(fdu.storage) == 0:
            #     st_n = 'root'
            #     st_v = json.loads(str(template_disk % ('/', 'default')))
            #     devices.update({st_n: st_v})
            # else:
            #     for s in fdu.storage:
            #         st_n = s.get('name')
            #         st_v = json.loads(str(template_disk % (s.get('path'), s.get('pool'))))
            #         devices.update({st_n: st_v})

        # devices = Environment().from_string(template)
        # devices = devices.render(networks=entity.networks)
        mid = {'machine-id': {'path': '/etc/machine-id', 'source': '/etc/machine-id', 'type': 'disk'}}
        devices.update(mid)
        self.logger.info('__generate_custom_profile_devices_configuration()', 'LXD Plugin - Container Devices {}'.format(devices))
        return devices

    def __generate_container_dict(self, instance):
        conf = {'name': instance.name, 'profiles': instance.profiles,
                'source': {'type': 'image', 'alias': instance.image.get('uuid')}}
        self.logger.info('__generate_container_dict()', 'LXD Plugin - Container Configuration {}'.format(conf))
        return conf

    def __force_fdu_termination(self, fdu_uuid):
        self.logger.info('stop_fdu()', ' LXD Plugin - Stop a container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('stop_fdu()', 'LXD Plugin - FDU not exists')
        else:
            if fdu.get_state() == State.PAUSED:
                self.resume_fdu(fdu_uuid)
                self.stop_fdu(fdu_uuid)
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_state() == State.RUNNING:
                self.stop_fdu(fdu_uuid)
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_state() == State.CONFIGURED:
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_state() == State.DEFINED:
                self.undefine_fdu(fdu_uuid)

    def __monitor_instance(self, fdu_uuid, name):
        self.logger.info('__monitor_instance()', '[ INFO ] LXD Plugin - Staring monitoring of Container uuid {}'.format(fdu_uuid))
        time.sleep(2)
        while True:
            time.sleep(2)
            container_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            try:
                c = self.conn.containers.get(name)
                cs = c.state()
                detailed_state = {}
                detailed_state.update({'network':cs.network})
                detailed_state.update({'cpu':cs.cpu})
                detailed_state.update({'memory':cs.memory})
                detailed_state.update({'disk':cs.disk})
                detailed_state.update({'processes':cs.processes})
                detailed_state.update({'pid':cs.pid})
                container_info.update({'detailed_state': detailed_state})
                self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, container_info)

                if c.status == 'Stopped':
                    self.logger.info('__monitor_instance()', '[ INFO ] LXD Plugin - Stopping monitoring of Container uuid {}'.format(fdu_uuid))
                    return
            except Exception as e:
                self.logger.error('__monitor_instance()', '[ ERROR ] LXD Plugin - Stopping monitoring of Container uuid {} Error {}'.format(fdu_uuid, e))
                return

    def __get_bridge_names_from_instance_networks(self, instance_networks):
        return [network['br_name'] for network in instance_networks]

    # def __add_image(self, manifest):
    #     url = manifest.get('base_image')
    #     uuid = manifest.get('uuid')
    #     if url.startswith('http'):
    #         image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, url.split('/')[-1])
    #         self.agent.get_os_plugin().download_file(url, image_name)
    #     elif url.startswith('file://'):
    #         image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, url.split('/')[-1])
    #         cmd = 'cp {} {}'.format(url[len('file://'):], image_name)
    #         self.agent.get_os_plugin().execute_command(cmd, True)

    #     self.logger.info('__add_image()', '[ INFO ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, url)))
    #     image_data = self.agent.get_os_plugin().read_binary_file(os.path.join(self.BASE_DIR, self.IMAGE_DIR, image_name))
    #     self.logger.info('__add_image()', '[ DONE ] LXD Plugin - Loading image data from: {}'.format(os.path.join(self.BASE_DIR, self.IMAGE_DIR, url)))
    #     img_info = {'url': url, 'path': image_name, 'uuid': uuid}

    #     self.logger.info('__add_image()', '[ INFO ] LXD Plugin - Creating image with alias {}'.format(uuid))
    #     img = self.conn.images.create(image_data, public=True, wait=True)
    #     img.add_alias(uuid, description=image_name)
    #     self.logger.info('__add_image()', '[ DONE ] LXD Plugin - Created image with alias {}'.format(uuid))
    #     self.images.update({uuid: img_info})
    #     manifest.update({'path': image_name})
    #     uri = '{}/{}'.format(self.HOME_IMAGE, manifest.get('uuid'))
    #     self.__update_actual_store(uri, manifest)

    # def __remove_image(self, image_uuid):
    #     image = self.images.get(image_uuid, None)
    #     if image is None:
    #         self.logger.info('__remove_image()', ' LXD Plugin - Image not found!!')
    #         return
    #     self.agent.get_os_plugin().remove_file(image.get('path'))
    #     self.images.pop(image_uuid)
    #     uri = '{}/{}'.format(self.HOME_IMAGE, image_uuid)
    #     self.__pop_actual_store(uri)

    # def __add_flavor(self, manifest):
    #     uri = '{}/{}'.format(self.HOME_FLAVOR, manifest.get('uuid'))
    #     self.__update_actual_store(uri, manifest)
    #     self.flavors.update({manifest.get('uuid'): manifest})

    # def __remove_flavor(self, flavor_uuid):
    #     self.flavors.pop(flavor_uuid)
    #     uri = '{}/{}'.format(self.HOME_FLAVOR, flavor_uuid)
    #     self.__pop_actual_store(uri)


    def __fdu_observer(self, fdu_info):
        self.logger.info('__fdu_observer()', ' LXD Plugin - New Action of a FDU - FDU Info: {}'.format(fdu_info))
        action = fdu_info.get('status')
        fdu_uuid = fdu_info.get('uuid')
        react_func = self.__react(action)
        if action == 'undefine':
            self.logger.info('__fdu_observer()', ' LXD Plugin - This is a remove for : {}'.format(fdu_info))
            self.undefine_fdu(fdu_uuid)
        elif action == 'define':
            self.logger.info('__fdu_observer()', ' LXD Plugin - This is a define for : {}'.format(fdu_info))
            self.define_fdu(fdu_info)
        elif react_func is not None:
            react_func(fdu_uuid)
        else:
            self.logger.info('__fdu_observer()', ' LXD Plugin - Action not recognized : {}'.format(action))

    def __react(self, action):
        r = {
            'configure': self.configure_fdu,
            'stop': self.stop_fdu,
            'resume': self.resume_fdu,
            'run': self.run_fdu,
            'clean': self.clean_fdu,
            # 'landing': self.migrate_entity,
            # 'taking_off': self.migrate_entity
        }

        return r.get(action, None)


def read_file(file_path):
    data = ''
    with open(file_path, 'r') as f:
        data = f.read()
    return data


if __name__ == '__main__':
    if len(sys.argv) < 2:
        exit(-1)
    print('ARGS {}'.format(sys.argv))
    file_dir = os.path.dirname(__file__)
    manifest = json.loads(read_file(sys.argv[1]))
    na = LXD(manifest.get('name'), manifest.get('version'), manifest.get(
        'uuid'), manifest)
    na.start_runtime()