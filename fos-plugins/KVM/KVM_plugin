#!/usr/bin/env python3

# Copyright (c) 2014,2018 ADLINK Technology Inc.
#
# See the NOTICE file(s) distributed with this work for additional
# information regarding copyright ownership.
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Apache License, Version 2.0
# which is available at https://www.apache.org/licenses/LICENSE-2.0.
#
# SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
#
# Contributors: Gabriele Baldoni, ADLINK Technology Inc. - Base plugins set

import sys
import os
import uuid
import json
import signal
import random
import time
import re
import libvirt
import ipaddress
import threading
import base64
import binascii
from mvar import MVar
from fog05 import Yaks_Connector
from fog05.DLogger import DLogger
from fog05.interfaces.States import State
from fog05.interfaces.RuntimePluginFDU import *
from KVMFDU import KVMFDU
from jinja2 import Environment


class KVM(RuntimePluginFDU):

    def __init__(self, name, version, plugin_uuid, manifest):
        super(KVM, self).__init__(version, plugin_uuid)
        self.name = name
        loc = manifest.get('configuration').get('ylocator').split('/')[1]
        self.connector = Yaks_Connector(loc)
        self.logger = DLogger(debug_flag=True)
        self.node = manifest.get('configuration').get('nodeid')
        self.manifest = manifest
        self.configuration = manifest.get('configuration',{})
        self.pid = os.getpid()
        self.var = MVar()
        self.agent_conf = \
            self.connector.loc.actual.get_node_configuration(self.node)

        self.logger.info('__init__()', ' Hello from KVM Plugin')
        self.BASE_DIR = os.path.join(
            self.agent_conf.get('agent').get('path'),'kvm')
        self.DISK_DIR = 'disks'
        self.IMAGE_DIR = 'images'
        self.LOG_DIR = 'logs'
        file_dir = os.path.dirname(__file__)
        self.DIR = os.path.abspath(file_dir)
        self.conn = None
        self.images = {}
        self.flavors = {}
        self.nm = self.get_nm_plugin().get('uuid')
        signal.signal(signal.SIGINT, self.__catch_signal)
        signal.signal(signal.SIGTERM, self.__catch_signal)

    def __catch_signal(self, signal, _):
        if signal in [2,15]:
            self.var.put(signal)

    def start_runtime(self):
        self.logger.info('startRuntime()', ' KVM Plugin - Connecting to KVM')
        self.conn = libvirt.open('qemu:///system')
        self.logger.info('startRuntime()', '[ DONE ] KVM Plugin - Connecting to KVM')

        '''check if dirs exists if not exists create'''
        # TODO change the implementation of call_os_plugin_function to mask the name of parameters
        if self.call_os_plugin_function('dir_exists', {'dir_path': self.BASE_DIR}):
            if not self.call_os_plugin_function('dir_exists', {'dir_path': os.path.join(self.BASE_DIR, self.DISK_DIR)}):
                self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.DISK_DIR)})
            if not self.call_os_plugin_function('dir_exists', {'dir_path': os.path.join(self.BASE_DIR, self.IMAGE_DIR)}):
                self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.IMAGE_DIR)})
            if not self.call_os_plugin_function('dir_exists', {'dir_path': os.path.join(self.BASE_DIR, self.LOG_DIR)}):
                self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.LOG_DIR)})
        else:
            self.call_os_plugin_function(
                'create_dir', {'dir_path': os.path.join(self.BASE_DIR)})
            self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.DISK_DIR)})
            self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.IMAGE_DIR)})
            self.call_os_plugin_function(
                    'create_dir', {'dir_path': os.path.join(self.BASE_DIR, self.LOG_DIR)})

        self.connector.loc.desired.observe_node_runtime_fdus(self.node, self.uuid, self.__fdu_observer)

        self.manifest.update({'pid': self.pid})
        self.manifest.update({'status': 'running'})
        self.connector.loc.actual.add_node_plugin(self.node, self.uuid, self.manifest)

        self.logger.info('start_runtime()', ' KVM Plugin - Started...')

        r = self.var.get()
        self.stop_runtime()
        self.connector.close()
        exit(0)


    def stop_runtime(self):
        self.logger.info('stopRuntime()', ' KVM Plugin - Destroying running domains')

        for k in list(self.current_fdus.keys()):
            fdu = self.current_fdus.get(k)
            self.__force_fdu_termination(k)
            if fdu.get_state() == State.DEFINED:
                self.undefine_fdu(k)

        for k in list(self.images.keys()):
            self.__remove_image(k)
        for k in list(self.flavors.keys()):
            self.__remove_flavor(k)

        try:
            self.conn.close()
        except libvirt.libvirtError as err:
            pass
        self.logger.info('stopRuntime()', '[ DONE ] KVM Plugin - Bye Bye')

    def get_fdus(self):
        return self.current_fdus

    def define_fdu(self, fdu_record):

        self.logger.info('define_fdu()', ' KVM Plugin - Defining a VM')

        entity = None
        img = None
        flavor = None

        fdu_uuid = fdu_record.get('fdu_uuid')
        descriptor = self.get_fdu_descriptor(fdu_uuid)
        fdu = KVMFDU.from_descriptor(descriptor)

        if self.is_uuid(fdu.get_image_uri()):
            img = self.images.get(fdu.get_image_uri(), None)
            if img is None:
                self.logger.error('define_fdu()', '[ ERRO ] KVM Plugin - Cannot find image {}'.format(fdu.get_image_uri()))
                # TODO write error using Yaks_connector
                return
            else:
                fdu.image.update({'file':img.get('base_image')})
                fdu.image.update({'uuid':img.get('uuid')})

        else:
            self.logger.warning('define_fdu()', '[ WARN ] KVM Plugin - No image id specified defining from manifest information new image id uuid:{}'.format(fdu_uuid))
            if fdu.get_image_uri().startswith('http'):
                image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])
                self.call_os_plugin_function('download_file',{'url':fdu.get_image_uri(),'file_path':image_name})
            elif fdu.get_image_uri().startswith('file://'):
                image_name = os.path.join(
                    self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])
                cmd = 'cp {} {}'.format(fdu.get_image_uri()[len('file://'):], image_name)
                self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})


            img_info = {}
            img_info.update({'uuid': fdu_uuid})
            img_info.update({'name': '{}_img'.format(fdu.name)})
            img_info.update({'base_image': image_name})
            img_info.update({'type':'kvm'})
            img_info.update({'format': fdu.get_image_format()})

            fdu.image.update({'file': image_name})
            fdu.image.update({'uuid': fdu_uuid})

            self.__add_image(img_info)
            img = self.images.get(fdu_uuid, None)
            if img is None:
                self.logger.error('define_fdu()', '[ ERRO ] KVM Plugin - Cannot find image {}'.format(fdu_uuid))

        self.logger.info('define_fdu()', '[ WARN ] KVM Plugin - New flavor uuid:{}'.format(fdu_uuid))
        cpu = fdu.comp_requirements.get('cpu_min_count')
        mem = fdu.comp_requirements.get('ram_size_mb')
        disk_size = fdu.comp_requirements.get('storage_size_gb')
        flavor_info = {}
        flavor_info.update({'name': '{}_flavor'.format(fdu.name)})
        flavor_info.update({'uuid': fdu_uuid})
        flavor_info.update({'cpu': cpu})
        flavor_info.update({'memory': mem})
        flavor_info.update({'disk_size': disk_size})
        flavor_info.update({'type':'kvm'})
        fdu.comp_requirements.update({'uuid': fdu_uuid})
        self.__add_flavor(flavor_info)
        flavor = self.flavors.get(fdu_uuid, None)
        if flavor is None:
            self.logger.error('define_fdu()', '[ ERRO ] KVM Plugin - Cannot find flavor {}'.format(fdu_uuid))

        fdu.on_define()


        vm_info = self.connector.loc.desired.get_node_fdu(self.node, self.uuid, fdu_uuid)
        vm_info.update({'status': 'DEFINE'})
        self.current_fdus.update({fdu_uuid: fdu})
        self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, vm_info)
        self.logger.info('define_fdu()', '[ DONE ] KVM Plugin - VM Defined uuid: {}'.format(fdu_uuid))

    def undefine_fdu(self, fdu_uuid):

        self.logger.info('undefine_fdu()', ' KVM Plugin - Undefine a VM uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('undefine_fdu()', 'KVM Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing', 'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))

        elif fdu.get_state() != State.DEFINED:
            self.logger.error('undefine_fdu()', 'KVM Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in DEFINED state', 'FDU {} is not in DEFINED state'.format(fdu_uuid))
        else:
            if (self.current_fdus.pop(fdu_uuid, None)) is None:
                self.logger.warning('undefine_fdu()', 'KVM Plugin - pop from entities dict returned none')


            image_name = fdu.image.get('file')
            self.call_os_plugin_function('remove_file',{'file_path':image_name})
            self.images.pop(fdu_uuid)
            self.flavors.pop(fdu_uuid)
            self.connector.loc.actual.remove_node_fdu(self.node, self.uuid, fdu_uuid)
            self.logger.info('undefine_fdu()', '[ DONE ] KVM Plugin - Undefine a VM uuid {} '.format(fdu_uuid))

    def configure_fdu(self, fdu_uuid):

        self.logger.info('configure_fdu()', ' KVM Plugin - Configure a VM uuid {} '.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('configure_fdu()', 'KVM Plugin - FDU not exists')

            raise FDUNotExistingException('FDU not existing', 'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.DEFINED:
            self.logger.error('configure_fdu()', 'KVM Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in DEFINED state', 'FDU {} is not in DEFINED state'.format(fdu_uuid))
        else:

            name = fdu.name
            flavor = self.flavors.get(fdu_uuid, None)
            img = self.images.get(fdu_uuid, None)
            if flavor is None:
                self.logger.error('configure_fdu()', '[ ERRO ] KVM Plugin - Cannot find flavor {}'.format(fdu.flavor_id))
                return

            if img is None:
                self.logger.error('configure_fdu()', '[ ERRO ] KVM Plugin - Cannot find image {}'.format(fdu.image_id))
                return

            disk_path = '{}.{}'.format(fdu_uuid, img.get('format'))
            cdrom_path = '{}_config.iso'.format(fdu_uuid)
            disk_path = os.path.join(self.BASE_DIR, self.DISK_DIR, disk_path)
            cdrom_path = os.path.join(self.BASE_DIR, self.DISK_DIR, cdrom_path)

            fdu.disk = disk_path
            fdu.cdrom = cdrom_path


            for cp in fdu.get_connection_points():
                    cp_id = cp.get('uuid')
                    cp_id = cp.get('uuid')
                    cp_record = {
                        'cp_uuid':cp_id,
                        'status':'CREATE'
                    }
                    self.connector.loc.desired.add_node_port(self.node, self.nm, cp_id,cp_record)
                    res = self.connector.loc.actual.get_node_port(self.node, self.nm, cp_id)
                    while res is None:
                        res = self.connector.loc.actual.get_node_port(self.node, self.nm, cp_id)

            net_cfg = []
            if fdu.get_interfaces() is not None:
                for i, intf in enumerate(fdu.get_interfaces()):
                    intf_name = intf.get('name')
                    mac = intf.get('mac_address', self.__generate_random_mac())
                    if intf.get('virtual_interface').get('intf_type').upper() in ['PHYSICAL','BRIDGED']:
                        real_intf_name = intf.get('virtual_interface').get('vpci')
                        if self.call_os_plugin_function('get_intf_type', {'name': real_intf_name}) in ['ethernet']:
                            net_cfg.append({'name':intf_name, 'mac':mac, 'dev':real_intf_name,'type':'direct'})
                            self.call_os_plugin_function('set_interface_unaviable', {'intf_name': real_intf_name})
                        elif self.call_os_plugin_function('get_intf_type', {'name': real_intf_name}) in ['wireless']:
                            net_cfg.append({'name':intf_name, 'mac':mac, 'dev':real_intf_name,'type':'direct'})
                            self.call_os_plugin_function('set_interface_unaviable', {'intf_name': real_intf_name})
                        else:
                            net_cfg.append({'name':intf_name, 'mac':mac, 'dev':real_intf_name})
                    else:
                        intf_id = 'kvm-{}-{}'.format(fdu.get_short_id(), i)
                        intf_data = self.connector.loc.actual.get_node_port(self.node, self.nm, intf.get('cp_id')).get('properties')
                        #self.call_nw_plugin_function('create_virtual_interface', {'intf_id':intf_id, 'descriptor': intf})
                        self.logger.info('configure_fdu()','KVM Plugin - Interface info {}'.format(intf_data))
                        dev_name = intf_data.get('cp_name')
                        net_cfg.append({'name':intf_name, 'mac':mac, 'dev':dev_name})


            vm_xml = self.__generate_dom_xml(fdu, flavor, img, net_cfg)
            xml_file_name = 'kvm-{}.xml'.format(fdu_uuid)
            vm_xml_store = binascii.hexlify(base64.b64encode(bytes(vm_xml, 'utf-8'))).decode()
            self.call_os_plugin_function('store_file',{'content':vm_xml_store, 'file_path':self.BASE_DIR, 'filename':xml_file_name})

            vendor_conf = self.__generate_vendor_data(fdu_uuid, self.node)
            vendor_filename = 'vendor_{}.yaml'.format(fdu_uuid)
            vendor_conf = binascii.hexlify(base64.b64encode(bytes(vendor_conf, 'utf-8'))).decode()
            self.call_os_plugin_function('store_file',{'content':vendor_conf, 'file_path':self.BASE_DIR, 'filename':vendor_filename})
            vendor_filename = os.path.join(self.BASE_DIR, vendor_filename)
            ### creating cloud-init initial drive TODO: check all the possibilities provided by OSM
            conf_cmd = '{} --hostname {} --uuid {} --vendor-data {}'.format(os.path.join(self.DIR, 'templates',
                                                                        'create_config_drive.sh'), fdu.name, fdu_uuid,
                                                                          vendor_filename)

            rm_temp_cmd = 'rm'
            if fdu.configuration is not None:
                if fdu.configuration.get('conf_type') in ['CLOUD_INIT']:
                    c_init_file = fdu.configuration.get('script')
                    data_filename = 'userdata_{}'.format(fdu_uuid)
                    userdata = binascii.hexlify(base64.b64encode(bytes(fdu.c_init_file, 'utf-8'))).decode()
                    self.call_os_plugin_function('store_file',{'content':userdata, 'file_path':self.BASE_DIR, 'filename':data_filename})
                    data_filename = os.path.join(self.BASE_DIR, data_filename)
                    conf_cmd = conf_cmd + ' --user-data {}'.format(data_filename)
            if fdu.ssh_key is not None and fdu.ssh_key != '':
                key_filename = 'key_{}.pub'.format(fdu_uuid)
                keydata = binascii.hexlify(base64.b64encode(bytes(fdu.ssh_key, 'utf-8'))).decode()
                self.call_os_plugin_function('store_file',{'content':keydata, 'file_path':self.BASE_DIR, 'filename':key_filename})
                key_filename = os.path.join(self.BASE_DIR, key_filename)
                conf_cmd = conf_cmd + ' --ssh-key {}'.format(key_filename)


            conf_cmd = conf_cmd + ' {}'.format(fdu.cdrom)
            #############

            qemu_cmd = 'qemu-img create -f {} {} {}G'.format(img.get('format'), fdu.disk, int(flavor.get('disk_size')))

            # As in the first example, but the output format will be qcow2 instead of a raw  disk:
            #
            # qemu-img create -f qcow2 -o preallocation=metadata newdisk.qcow2 15G
            # virt-resize --expand /dev/sda2 olddisk newdisk.qcow2

            dd_cmd = 'dd if={} of={}'.format(img.get('base_image'), fdu.disk)

            self.call_os_plugin_function('execute_command',{'command':qemu_cmd,'blocking':True, 'external':False})
            self.call_os_plugin_function('execute_command',{'command':conf_cmd,'blocking':True, 'external':False})
            self.call_os_plugin_function('execute_command',{'command':dd_cmd,'blocking':True, 'external':False})

            if fdu.ssh_key is not None and fdu.ssh_key != '':
                self.call_os_plugin_function('remove_file',{'file_path':key_filename})
            if fdu.configuration is not None:
                if fdu.configuration.get('conf_type') in ['CLOUD_INIT']:
                    self.call_os_plugin_function('remove_file',{'file_path':data_filename})
            self.call_os_plugin_function('remove_file',{'file_path':vendor_filename})

            try:
                self.conn.defineXML(vm_xml)
            except libvirt.libvirtError as err:
                self.conn = libvirt.open('qemu:///system')
                self.conn.defineXML(vm_xml)

            fdu.on_configured(vm_xml)
            self.current_fdus.update({fdu_uuid: fdu})

            vm_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            vm_info.update({'status': 'CONFIGURE'})
            self.current_fdus.update({fdu_uuid: fdu})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, vm_info)
            self.logger.info('configure_fdu()', '[ DONE ] KVM Plugin - Configure a VM uuid {}'.format(fdu_uuid))


    def clean_fdu(self, fdu_uuid):

        self.logger.info('clean_fdu()', ' KVM Plugin - Clean a VM uuid {} '.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('clean_fdu()', 'KVM Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing', 'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.CONFIGURED:
            self.logger.error('clean_fdu()', 'KVM Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in CONFIGURED state', 'FDU {} is not in CONFIGURED state'.format(fdu_uuid))
        else:

            dom = self.__lookup_by_uuid(fdu_uuid)
            if dom is not None:
                dom.undefine()
            else:
                self.logger.error('clean_fdu()', 'KVM Plugin - Domain  not found!!')

            vmlog = '{}_log.log'.format(fdu_uuid)
            self.call_os_plugin_function('remove_file',{'file_path':fdu.cdrom})
            self.call_os_plugin_function('remove_file',{'file_path':fdu.disk})
            self.call_os_plugin_function('remove_file',{'file_path':os.path.join(self.BASE_DIR, self.LOG_DIR, vmlog)})
            xml_file_name = 'kvm-{}.xml'.format(fdu_uuid)
            self.call_os_plugin_function('remove_file',{'file_path':os.path.join(self.BASE_DIR, xml_file_name)})

            for i, intf in enumerate(fdu.get_interfaces()):
                intf_name = intf.get('name')
                if intf.get('virtual_interface').get('intf_type').upper() not in ['PHYSICAL','BRIDGED']:
                    intf_id = 'kvm-{}-{}'.format(fdu.get_short_id(), i)
                    #self.call_nw_plugin_function('delete_virtual_interface',{'intf_id':intf_id})
                else:
                    real_intf_name = intf.get('virtual_interface').get('vpci')
                    self.call_os_plugin_function('set_interface_available', {'intf_name': real_intf_name})

            for cp in fdu.get_connection_points():
                cp_id = cp.get('uuid')
                cp = self.connector.loc.actual.get_node_port(self.node, self.nm, cp_id)
                cp.update({'status':'DESTROY'})
                self.connector.loc.desired.add_node_port(self.node, self.nm, cp_id, cp)


            fdu.on_clean()
            self.current_fdus.update({fdu_uuid: fdu})
            vm_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            vm_info.update({'status': 'DEFINE'})
            # TODO: this should be an update when YAKS will implement update
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, vm_info)
            self.logger.info('clean_fdu()', '[ DONE ] KVM Plugin - Clean a VM uuid {} '.format(fdu_uuid))


    def run_fdu(self, fdu_uuid):

        self.logger.info('run_fdu()', 'KVM Plugin - Starting a VM uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('run_fdu()', 'KVM Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing', 'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.CONFIGURED:
            self.logger.error('run_fdu()', 'KVM Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in CONFIGURED state', 'FDU {} is not in CONFIGURED state'.format(fdu_uuid))
        else:
            vm_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            vm_info.update({'status': 'STARTING'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, vm_info)

            dom = self.__lookup_by_uuid(fdu_uuid)
            dom.create()
            while dom.state()[0] != 1:
               pass
            self.logger.info('run_fdu()', ' KVM Plugin - VM {} Started!'.format(fdu_uuid))

            fdu.on_start()
            # log_filename = '{}/{}/{}_log.log'.format(self.BASE_DIR, self.LOG_DIR, instance_uuid)
            # if instance.user_file is not None and instance.user_file != '':
            #     self.__wait_boot(log_filename, True)
            # else:
            #     self.__wait_boot(log_filename)

            self.current_fdus.update({fdu_uuid: fdu})

            vm_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            vm_info.update({'status': 'RUN'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, vm_info)

            self.logger.info('run_fdu()', '[ DONE ] KVM Plugin - Starting a VM uuid {}'.format(fdu_uuid))


    def stop_fdu(self, fdu_uuid):

        self.logger.info('stop_fdu()', ' KVM Plugin - Stop a VM uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('stop_fdu()', 'KVM Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing', 'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.RUNNING:
            self.logger.error('stop_fdu()', 'KVM Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in RUNNING state', 'FDU {} is not in RUNNING state'.format(fdu_uuid))
        else:

            dom = self.__lookup_by_uuid(fdu_uuid)
            dom.shutdown()
            retries = 100
            for i in range(0, retries):
                if dom.state()[0] != 5:
                    break
                else:
                    time.sleep(0.015)

            if dom.state()[0] != 5:
                dom.destroy()

            fdu.on_stop()
            self.current_fdus.update({fdu_uuid: fdu})

            vm_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            vm_info.update({'status': 'CONFIGURE'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, vm_info)
            self.logger.info('stop_fdu()', '[ DONE ] KVM Plugin - Stop a VM uuid {}'.format(fdu_uuid))


    def pause_fdu(self, fdu_uuid):

        self.logger.info('pause_fdu()', ' KVM Plugin - Pause a VM uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('pause_fdu()', 'KVM Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing', 'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.RUNNING:
            self.logger.error('pause_fdu()', 'KVM Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in RUNNING state', 'FDU {} is not in RUNNING state'.format(fdu_uuid))
        else:
            self.__lookup_by_uuid(fdu_uuid).suspend()
            fdu.on_pause()
            self.current_fdus.update({fdu_uuid: fdu})
            vm_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
            vm_info.update({'status': 'PAUSE'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, vm_info)
            self.logger.info('pause_fdu()', '[ DONE ] KVM Plugin - Pause a VM uuid {}'.format(fdu_uuid))

    def resume_fdu(self, fdu_uuid):

        self.logger.info('resume_fdu()', ' KVM Plugin - Resume a VM uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('resume_fdu()', 'KVM Plugin - FDU not exists')
            raise FDUNotExistingException('FDU not existing', 'FDU {} not in runtime {}'.format(fdu_uuid, self.uuid))
        elif fdu.get_state() != State.PAUSED:
            self.logger.error('resume_fdu()', 'KVM Plugin - FDU state is wrong, or transition not allowed')
            raise StateTransitionNotAllowedException('FDU is not in PAUSED state', 'FDU {} is not in PAUSED state'.format(fdu_uuid))
        else:
                    self.__lookup_by_uuid(fdu_uuid).resume()
                    fdu.on_resume()
                    self.current_fdus.update({fdu_uuid: fdu})
                    vm_info = self.connector.loc.actual.get_node_fdu(self.node, self.uuid, fdu_uuid)
                    vm_info.update({'status': 'RUN'})
                    self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, vm_info)
                    self.logger.info('resume_fdu()', '[ DONE ] KVM Plugin - Resume a VM uuid {}'.format(fdu_uuid))
                    return True

    # TODO rethink the migration workflow to be faster, copy the disk first and copy the base image only when migration ended
    def migrate_fdu(self, fdu_uuid):
        record = self.connector.loc.desired.get_node_fdu(self.node, self.uuid, fdu_uuid)
        destination = record.get('migration_properties').get('destination')
        if destination != self.node:
            self.logger.info('migrate_fdu()', '[ DONE ] KVM Plugin - Source Node preparation...')
            fdu = self.current_fdus.get(fdu_uuid, None)
            if fdu_uuid is None:
                self.logger.error('migrate_fdu','FDU not in Runtime!!')
                return

            self.logger.info('migrate_fdu()', '[ DONE ] KVM Plugin - Source Node wait destination...')
            self.wait_destination_ready(fdu_uuid, destination)

            self.logger.info('migrate_fdu()', '[ DONE ] KVM Plugin - Migrating...')

            # ACTUAL MIGRATIION #
            dom = self.__lookup_by_uuid(fdu_uuid)
            dst_ip = self.get_destination_node_mgmt_net(destination).get('ipv4_address')
            dst_host = 'qemu+ssh://{}/system'.format(dst_ip)
            dest_conn = libvirt.open(dst_host)
            if dest_conn is None:
                self.logger.error('migrate_fdu()', 'KVM Plugin - Before Migration Source: Error on libvirt connection')
                record.pop('migration_properties')
                record.update({'status': 'ERROR'})
                record.update({'error_core':10})
                self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, record)
                return
            flags = libvirt.VIR_MIGRATE_LIVE | libvirt.VIR_MIGRATE_PERSIST_DEST
            new_dom = dom.migrate(dest_conn, flags, fdu.name, None, 0)
            # new_dom = dom.migrate(dest_conn, libvirt.VIR_MIGRATE_LIVE and libvirt.VIR_MIGRATE_PERSIST_DEST and libvirt.VIR_MIGRATE_NON_SHARED_DISK, name, None, 0)
            if new_dom is None:
                self.logger.error('migrate_fdu()', 'KVM Plugin - Before Migration Source: Migration failed')
                record.pop('migration_properties')
                record.update({'status': 'ERROR'})
                record.update({'error_core':10})
                self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, record)

                return
            self.logger.info('migrate_fdu()', ' KVM Plugin - Before Migration Source: Migration succeeds')
            dest_conn.close()
            #
            fdu.on_stop()
            self.current_fdus.update({fdu_uuid: fdu})
            self.clean_fdu(fdu_uuid)
            self.undefine_fdu(fdu_uuid)
            self.logger.info('migrate_fdu()', ' KVM Plugin - Source is Clean')



        else:
            record.update({'status': 'DEFINE'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, record)
            descriptor = self.get_fdu_descriptor(fdu_uuid)
            fdu = KVMFDU.from_descriptor(descriptor)
            image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])

            if fdu.get_image_uri().startswith('http'):
                image_name = os.path.join(self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])
                self.call_os_plugin_function('download_file',{'url':fdu.get_image_uri(),'file_path':image_name})
            elif fdu.get_image_uri().startswith('file://'):
                image_name = os.path.join(
                    self.BASE_DIR, self.IMAGE_DIR, fdu.get_image_uri().split('/')[-1])
                cmd = 'cp {} {}'.format(fdu.get_image_uri()[len('file://'):], image_name)
                self.call_os_plugin_function('execute_command',{'command':cmd,'blocking':True, 'external':False})

            self.logger.info('migrate_fdu()', '[ DONE ] KVM Plugin - Destination Node creating image and flavor...')

            img = {
                'uuid': fdu_uuid,
                'name': '{}_img'.format(fdu.name),
                'base_image': image_name,
                'type':'kvm',
                'format': fdu.get_image_format()
                }

            fdu.image.update({'file': image_name})
            fdu.image.update({'uuid': fdu_uuid})

            cpu = fdu.comp_requirements.get('cpu_min_count')
            mem = fdu.comp_requirements.get('ram_size_mb')
            disk_size = fdu.comp_requirements.get('storage_size_gb')
            flavor = {
                'name': '{}_flavor'.format(fdu.name),
                'uuid': fdu_uuid,
                'cpu': cpu,
                'memory': mem,
                'disk_size': disk_size,
                'type':'kvm'
                }
            fdu.comp_requirements.update({'uuid': fdu_uuid})

            self.__add_flavor(flavor)
            self.__add_image(img)


            disk_path = '{}.{}'.format(fdu_uuid, img.get('format'))
            cdrom_path = '{}_config.iso'.format(fdu_uuid)
            disk_path = os.path.join(self.BASE_DIR, self.DISK_DIR, disk_path)
            cdrom_path = os.path.join(self.BASE_DIR, self.DISK_DIR, cdrom_path)

            fdu.disk = disk_path
            fdu.cdrom = cdrom_path

            self.logger.info('migrate_fdu()', '[ DONE ] KVM Plugin - Destination Node creating Networks...')


            for cp in fdu.get_connection_points():
                    cp_id = cp.get('uuid')
                    cp_id = cp.get('uuid')
                    cp_record = {
                        'cp_uuid':cp_id,
                        'status':'CREATE'
                    }
                    self.connector.loc.desired.add_node_port(self.node, self.nm, cp_id,cp_record)
                    res = self.connector.loc.actual.get_node_port(self.node, self.nm, cp_id)
                    while res is None:
                        res = self.connector.loc.actual.get_node_port(self.node, self.nm, cp_id)

            net_cfg = []
            if fdu.get_interfaces() is not None:
                for i, intf in enumerate(fdu.get_interfaces()):
                    intf_name = intf.get('name')
                    mac = intf.get('mac_address', self.__generate_random_mac())
                    if intf.get('virtual_interface').get('intf_type').upper() in ['PHYSICAL','BRIDGED']:
                        real_intf_name = intf.get('virtual_interface').get('vpci')
                        if self.call_os_plugin_function('get_intf_type', {'name': real_intf_name}) in ['ethernet']:
                            net_cfg.append({'name':intf_name, 'mac':mac, 'dev':real_intf_name,'type':'direct'})
                            self.call_os_plugin_function('set_interface_unaviable', {'intf_name': real_intf_name})
                        elif self.call_os_plugin_function('get_intf_type', {'name': real_intf_name}) in ['wireless']:
                            net_cfg.append({'name':intf_name, 'mac':mac, 'dev':real_intf_name,'type':'direct'})
                            self.call_os_plugin_function('set_interface_unaviable', {'intf_name': real_intf_name})
                        else:
                            net_cfg.append({'name':intf_name, 'mac':mac, 'dev':real_intf_name})
                    else:
                        intf_id = 'kvm-{}-{}'.format(fdu.get_short_id(), i)
                        intf_data = self.connector.loc.actual.get_node_port(self.node, self.nm, intf.get('cp_id')).get('properties')
                        #self.call_nw_plugin_function('create_virtual_interface', {'intf_id':intf_id, 'descriptor': intf})
                        self.logger.info('migrate_fdu()','KVM Plugin - Interface info {}'.format(intf_data))
                        dev_name = intf_data.get('cp_name')
                        net_cfg.append({'name':intf_name, 'mac':mac, 'dev':dev_name})



            self.logger.info('migrate_fdu()', '[ DONE ] KVM Plugin - Destination Node creating disks...')

            vm_xml = self.__generate_dom_xml(fdu, flavor, img, net_cfg)
            xml_file_name = 'kvm-{}.xml'.format(fdu_uuid)
            vm_xml_store = binascii.hexlify(base64.b64encode(bytes(vm_xml, 'utf-8'))).decode()
            self.call_os_plugin_function('store_file',{'content':vm_xml_store, 'file_path':self.BASE_DIR, 'filename':xml_file_name})

            vendor_conf = self.__generate_vendor_data(fdu_uuid, self.node)
            vendor_filename = 'vendor_{}.yaml'.format(fdu_uuid)
            vendor_conf = binascii.hexlify(base64.b64encode(bytes(vendor_conf, 'utf-8'))).decode()
            self.call_os_plugin_function('store_file',{'content':vendor_conf, 'file_path':self.BASE_DIR, 'filename':vendor_filename})
            vendor_filename = os.path.join(self.BASE_DIR, vendor_filename)
            ### creating cloud-init initial drive TODO: check all the possibilities provided by OSM
            conf_cmd = '{} --hostname {} --uuid {} --vendor-data {}'.format(os.path.join(self.DIR, 'templates',
                                                                        'create_config_drive.sh'), fdu.name, fdu_uuid,
                                                                          vendor_filename)

            rm_temp_cmd = 'rm'
            if fdu.configuration is not None:
                if fdu.configuration.get('conf_type') in ['CLOUD_INIT']:
                    c_init_file = fdu.configuration.get('script')
                    data_filename = 'userdata_{}'.format(fdu_uuid)
                    userdata = binascii.hexlify(base64.b64encode(bytes(fdu.c_init_file, 'utf-8'))).decode()
                    self.call_os_plugin_function('store_file',{'content':userdata, 'file_path':self.BASE_DIR, 'filename':data_filename})
                    data_filename = os.path.join(self.BASE_DIR, data_filename)
                    conf_cmd = conf_cmd + ' --user-data {}'.format(data_filename)
            if fdu.ssh_key is not None and fdu.ssh_key != '':
                key_filename = 'key_{}.pub'.format(fdu_uuid)
                keydata = binascii.hexlify(base64.b64encode(bytes(fdu.ssh_key, 'utf-8'))).decode()
                self.call_os_plugin_function('store_file',{'content':keydata, 'file_path':self.BASE_DIR, 'filename':key_filename})
                key_filename = os.path.join(self.BASE_DIR, key_filename)
                conf_cmd = conf_cmd + ' --ssh-key {}'.format(key_filename)

            qemu_cmd = 'qemu-img create -f {} {} {}G'.format(img.get('format'), fdu.disk, int(flavor.get('disk_size')))
            conf_cmd = conf_cmd + ' {}'.format(fdu.cdrom)
            # THIS AS TO BE DONE IN DIFFERENT WAY
            dd_cmd = 'dd if={} of={}'.format(img.get('base_image'), fdu.disk)

            self.call_os_plugin_function('execute_command',{'command':qemu_cmd,'blocking':True, 'external':False})
            self.call_os_plugin_function('execute_command',{'command':conf_cmd,'blocking':True, 'external':False})

            # THIS AS TO BE DONE IN DIFFERENT WAY
            self.call_os_plugin_function('execute_command',{'command':dd_cmd,'blocking':True, 'external':False})
            if fdu.ssh_key is not None and fdu.ssh_key != '':
                self.call_os_plugin_function('remove_file',{'file_path':key_filename})
            if fdu.configuration is not None:
                if fdu.configuration.get('conf_type') in ['CLOUD_INIT']:
                    self.call_os_plugin_function('remove_file',{'file_path':data_filename})
            self.call_os_plugin_function('remove_file',{'file_path':vendor_filename})

            record.update({'status': 'LAND'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, record)
            self.logger.info('migrate_fdu()', '[ DONE ] KVM Plugin - Destination Node is ready for {}'.format(fdu_uuid))


            ### DESTINATION NODE WAIT FOR VM IN HYPERVISOR

            while True:
                    dom = self.__lookup_by_uuid(fdu_uuid)
                    if dom is None:
                        self.logger.info('migrate_fdu()', ' KVM Plugin - Domain not already in this host')
                    else:
                        if dom.isActive() == 1:
                            break
                        else:
                            self.logger.info('migrate_fdu()', ' KVM Plugin - Domain in this host but not running')
                    time.sleep(1)

            fdu.on_start()
            self.current_fdus.update({fdu_uuid: fdu})
            record.pop('migration_properties')
            record.update({'status': 'RUN'})
            self.connector.loc.actual.add_node_fdu(self.node, self.uuid, fdu_uuid, record)
            self.logger.info('migrate_fdu()', '[ DONE ] KVM Plugin - Migrate a VM uuid {}'.format(fdu_uuid))

                #
                # Here we shoudl copy the disk image somehow
                #




    def before_migrate_fdu_actions(self, fdu_uuid, dst=False):
        pass

    def after_migrate_fdu_actions(self, fdu_uuid, dst=False):
        pass

    def __add_image(self, manifest):
        img_uuid = manifest.get('uuid')
        self.images.update({img_uuid: manifest})
        self.connector.loc.actual.add_node_image(self.node, self.uuid, img_uuid, manifest)


    def __remove_image(self, image_uuid):

        image = self.images.get(image_uuid, None)
        if image is None:
            self.logger.info('__remove_image()', ' KVM Plugin - Image not found!!')
            return
        self.call_os_plugin_function('remove_file',{'file_path':image.get('path')})
        self.images.pop(image_uuid)
        self.connector.loc.actual.remove_node_image(self.node, self.uuid,image_uuid)


    def __add_flavor(self, manifest):
        #
        fl_uuid  = manifest.get('uuid')
        self.flavors.update({fl_uuid: manifest})
        self.connector.loc.actual.add_node_flavor(self.node, self.uuid, fl_uuid, manifest)

        #

    def __remove_flavor(self, flavor_uuid):
        self.flavors.pop(flavor_uuid)
        self.connector.loc.actual.remove_node_flavor(self.node, self.uuid,flavor_uuid)


    def __random_mac_generator(self):
        mac = [0x00, 0x16, 0x3e,
               random.randint(0x00, 0x7f),
               random.randint(0x00, 0xff),
               random.randint(0x00, 0xff)]
        return ':'.join(map(lambda x: '%02x' % x, mac))

    def __lookup_by_uuid(self, uuid):
        try:
            domains = self.conn.listAllDomains(0)
        except libvirt.libvirtError as err:
            self.conn = libvirt.open('qemu:///system')
            domains = self.conn.listAllDomains(0)

        if len(domains) != 0:
            for domain in domains:
                if str(uuid) == domain.UUIDString():
                    return domain
        else:
            return None

    def __wait_boot(self, filename, configured=False):
        time.sleep(5)
        if configured:
            boot_regex = r"\[.+?\].+\[.+?\]:.+Cloud-init.+?v..+running.+'modules:final'.+Up.([0-9]*\.?[0-9]+).+seconds.\n"
        else:
            boot_regex = r".+?login:()"
        while True:
            file = open(filename, 'r')
            import os
            # Find the size of the file and move to the end
            st_results = os.stat(filename)
            st_size = st_results[6]
            file.seek(st_size)

            while 1:
                where = file.tell()
                line = file.readline()
                if not line:
                    time.sleep(1)
                    file.seek(where)
                else:
                    m = re.search(boot_regex, str(line))
                    if m:
                        found = m.group(1)
                        return found

    def __force_fdu_termination(self, fdu_uuid):
        self.logger.info('stop_fdu()', ' KVM Plugin - Stop a container uuid {}'.format(fdu_uuid))
        fdu = self.current_fdus.get(fdu_uuid, None)
        if fdu is None:
            self.logger.error('stop_fdu()', 'KVM Plugin - FDU not exists')
        else:
            if fdu.get_state() == State.PAUSED:
                self.resume_fdu(fdu_uuid)
                self.stop_fdu(fdu_uuid)
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_state() == State.RUNNING:
                self.stop_fdu(fdu_uuid)
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_state() == State.CONFIGURED:
                self.clean_fdu(fdu_uuid)
                self.undefine_fdu(fdu_uuid)
            if fdu.get_state() == State.DEFINED:
                self.undefine_fdu(fdu_uuid)

    def __generate_dom_xml(self, fdu, flavor, image, net_cfg):
        template_xml = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vm.xml'), 'root':False})
        vm_xml = Environment().from_string(template_xml)
        vm_xml = vm_xml.render(name=fdu.name, uuid=fdu.uuid, memory=int(flavor.get('memory')),
                               cpu=flavor.get('cpu'), disk_image=fdu.disk,
                               iso_image=fdu.cdrom, networks=net_cfg, format=image.get('format'))
        return vm_xml

    def __generate_vendor_data(self, entityid, nodeid):
        vendor_yaml = self.call_os_plugin_function('read_file',{'file_path':os.path.join(self.DIR, 'templates', 'vendor_data.yaml'), 'root':False})
        vendor_conf = Environment().from_string(vendor_yaml)
        vendor_conf = vendor_conf.render(nodeid=nodeid, entityid=entityid)
        return vendor_conf


    def __netmask_to_cidr(self, netmask):
        return sum([bin(int(x)).count('1') for x in netmask.split('.')])


    def __generate_random_mac(self):
        d = [ 0x00, 0x16,
            random.randint(0x00, 0x7f),
            random.randint(0x00, 0x7f),
            random.randint(0x00, 0xff),
            random.randint(0x00, 0xff) ]
        return ':'.join(map(lambda x: "%02x" % x, d))

    def __fdu_observer(self, fdu_info):
        self.logger.info('__fdu_observer()', ' KVM Plugin - New Action of a FDU - FDU Info: {}'.format(fdu_info))
        action = fdu_info.get('status')
        fdu_uuid = fdu_info.get('fdu_uuid')
        react_func = self.__react(action)
        if action == 'UNDEFINE':
            self.logger.info('__fdu_observer()', ' KVM Plugin - This is a remove for : {}'.format(fdu_info))
            self.undefine_fdu(fdu_uuid)
        elif action == 'DEFINE':
            self.logger.info('__fdu_observer()', ' KVM Plugin - This is a define for : {}'.format(fdu_info))
            self.define_fdu(fdu_info)
        elif react_func is not None:
            react_func(fdu_uuid)
        else:
            self.logger.info('__fdu_observer()', ' KVM Plugin - Action not recognized : {}'.format(action))


    def __react(self, action):
        r = {
            'CONFIGURE': self.configure_fdu,
            'STOP': self.stop_fdu,
            'RESUME': self.resume_fdu,
            'RUN': self.run_fdu,
            'CLEAN': self.clean_fdu,
            'LAND': self.migrate_fdu,
            'TAKE_OFF': self.migrate_fdu
        }
        return r.get(action, None)


def read_file(file_path):
    data = ''
    with open(file_path, 'r') as f:
        data = f.read()
    return data


if __name__ == '__main__':
    if len(sys.argv) < 2:
        exit(-1)
    print('ARGS {}'.format(sys.argv))
    file_dir = os.path.dirname(__file__)
    manifest = json.loads(read_file(sys.argv[1]))
    vm = KVM(manifest.get('name'), manifest.get('version'), manifest.get(
        'uuid'), manifest)
    vm.start_runtime()
