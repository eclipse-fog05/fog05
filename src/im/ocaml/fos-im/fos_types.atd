(*********************************************************************************
 * Copyright (c) 2018 ADLINK Technology Inc.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0, or the Apache Software License 2.0
 * which is available at https://www.apache.org/licenses/LICENSE-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0
 * Contributors: 1
 *   Gabriele Baldoni (gabriele (dot) baldoni (at) adlinktech (dot) com ) - OCaml implementation
 *********************************************************************************)

type json <ocaml module="Abs_json"> = abstract
(* Atomit Entity Manifest *)





type fdu = {
  uuid : string;
  name : string;
  ?description : string option;
  ?image : image option;
  ?command : command option; (* Present only if hypervisor_type is BARE *)
  computation_requirements : computational_requirements;
  ?geographical_requirements : geographical_requirements option;
  ?energy_requirements : energy_requirements option;
  hypervisor : hv_kind;
  migration_kind :  migr_kind;
  ?configuration : configuration option;
  interfaces : interface list;
  io_ports : io_port list;
  connection_points : connection_point list;
  depends_on : string list;
}


type image = {
  ?uuid : string option;
  ?name : string option;
  uri : string;
  checksum : string;
  format : string;

}


type command = {
  binary : string;
  args : string list;
}

type geographical_requirements = {
  ?position : position option;
  ?proximity : proximity list option;
}

type energy_requirements = {
  key : string;
}

(* This is the flavor *)
type computational_requirements =  {
  ?uuid : string option;
  ?name : string option;
  cpu_arch : string;
  cpu_min_freq : float;
  cpu_min_count: int;
  ?gpu_min_count : int option;
  ?fpga_min_count : int option;
  ram_size_mb : float;
  storage_size_gb : float;
  ?duty_cycle : float option;
  (*
  ?min_running_time_minutes : int option;
  ?max_running_time_minutes : int option;
  *)
}

type position = {
  lat : string;
  lon : string;
  radius : float;
}

type proximity = {
  neighbour : string;
  radius : float;
}

type migr_kind = [
  | LIVE
  | COLD
]

type hv_kind = [
  | BARE
  | KVM
  | KVM_UK
  | XEN
  | XEN_UK
  | LXD
  | DOCKER
  | MCU
]

type conf_types = [
  | SCRIPT
  | CLOUD_INIT
]


type configuration = {
  conf_type : conf_types;
  script : string;
  ?ssh_keys : string list option;
}

type interface = {
  name : string;
  is_mgmt : bool;
  if_type : intf_t;
  ?mac_address : string option;
  virtual_interface : vif_type;
  ?cp_id : string option;
}

type vif_type = {
  intf_type : vintf_t;
  vpci : string; (* in case of bridged is the name of the bridge*)
  bandwidth : int;
}


type intf_t = [
  | INTERNAL
  | EXTERNAL
  | WLAN  (* then virtual_interface has to be PHYSICAL *)
  | BLUETOOTH (* then virtual_interface has to be PHYSICAL *)
]

type vintf_t = [
  | PARAVIRT
  | FOS_MGMT
  | PCI_PASSTHROUGH
  | SR_IOV
  | VIRTIO
  | E1000
  | RTL8139
  | PCNET
  | PHYSICAL
  | BRIDGED
]


type io_kind = [
  | GPIO
  | I2C
  | BUS
  | COM
]

type io_port = {
  address : string;
  io_kind : io_kind;
  min_io_ports : int
}

type connection_point = {
  uuid: string;
  ?pair_id : string option;
}


type virtual_network = {
  uuid : string;
  name : string;
  net_type : vn_type;
  is_mgmt : bool
}


type vn_type = [
  | ELINE
  | ELAN
 ]

(* This are the old entities/atomic entities *)

type atomic_entity = {
  uuid : string;
  name : string;
  atomic_type <json name="type">: string;
               version : int;
               entity_data : json;  (* this should be a JSON *)
               ?status: string option;
               ?constraints : constraints_type option;
               ?dst : string option;
               ?error : string option;
              }

type constraints_type = {
  ?i_o <json name="i/o"> : constraint_type list option;
  ?networks : constraint_type list option;
  ?accelerators : constraint_type list option;
  ?os_constraint <json name="os">: string option;
                  ?position : position_constraint_type option;
                  ?cpu_constraint : cpu_constraint_type option;
                  ?running_time_constraint : running_time_constraints_type option;
                  ?migration: migration_constraint_type option;
                 }

type constraint_type = {
  constratint_type <json name="type"> : string;
  number : int;
}

type position_constraint_type = {
  lat : string;
  lon : string;
  radius : int;
}

type migration_constraint_type = {
  kill_before: bool; (* true=can kill VNF before it has been copied *)
  script: string; (* Migration script to execute *)
}

type cpu_constraint_type = {
  arch_constraint <json name="arch"> : string;
  min_cpu_freq : float;
  min_cpu_cores : int;
}

type running_time_constraints_type = {
  min_time_minutes : int;
  max_time_minutes : int;
}

(* Entity Manifest *)
type entity = {
  uuid : string;
  name : string;
  export: bool; (* If entity service is exported to EFS service platform *)
  ?export_info : service_info_type option;
  entity_type <json name="type"> : string;
  components : component_type list;
  ?status : string option;
  ?description : string option;
  ?networks : network list option;
  dependencies: dependency_type list;
}

type dependency_type = {
  target_uuid : string; (* uuid of the entity or mec_application *)
  target_info : service_info_type;
  requested_permissions : permission_type list;
}


type service_info_type = {
  service_name : string;
  category : string;
  version : string;
  transport : transport_description_type;
  api_calls : api_type list;
}

type transport_description_type = {
  protocol : string;
  version : string;
  security : string;
  endpoint : string;
  serializers : string list; (* "JSON", "XML", "protobuf3" *)
}



type permission_type = {
  api_uuid : string; (* references an api_type *)
  requested_operations : string list;
}

type api_type = {
  uuid : string;
  uri : string;
  supported_operations : string list; (* [GET, POST, ...] *)
}

type component_type = {
  name : string;
  manifest : atomic_entity;
  ?node : string option;
  need : string list;
  ?proximity : string option;
  ?dns: dns_type option;
}

type dns_type = {
  id : string;
  domainName : string;
  ipAddressType : string; (* IPv4 or IPv6 *)
  ipAddress : string;
  ttl : int;
}


(* Plugin manifest *)
type plugin = {
  uuid : string;
  name : string;
  version : int;
  plugin_type <json name="type"> : string;
  ?status : string option;
  ?requirements : string list option;
  ?description : string option;
  ?url : string option;
  ?configuration : json option;
}


(* VM/CONTAINERS FLAVOR AND IMAGES *)

type image_old = {
  uuid : string;
  name : string;
  base_image :  string;
  img_type <json name="type"> : string;
  ?format : string option;
  ?path : string option;
  ?status : string option;
}

type flavor = {
  uuid : string;
  name : string;
  flv_type <json name="type">  : string;
  ?cpu_flavor <json name="cpu"> : int option;
  ?memory_flavor <json name="memory"> : int option;
  ?disk_size_flavor <json name="disk_size"> : int option;
  ?status : string option;
}


(* NODE INFORMATION *)
type node_info = {
  uuid : string;
  name : string;
  os : string;
  cpu : cpu_spec_type list;
  ram : ram_spec_type;
  disks : disks_spec_type list;
  io : io_spec_type list;
  accelerator : accelerator_spec_type list;
  network : network_spec_type list;
  ?position : pos_spec_type option;
  ?volatility : volatility_spec_type option;
}


type cpu_spec_type = {
  model : string;
  frequency : float;
  arch : string;
}


type ram_spec_type = {
  size : float;
}

type disks_spec_type = {
  local_address : string;
  dimension : float;
  mount_point : string;
  filesystem : string;
}

type io_spec_type = {
  name : string;
  io_type : string;
  io_file : string;
  available : bool;
}

type volatility_spec_type = {
  avg_avilability_minutes : int;
  quartiles_availavility_minutes : int list;
}

type accelerator_spec_type = {

  hw_address : string;
  name : string;
  supported_library : string list;
  available : bool;

}

type network_spec_type = {
  intf_name : string;
  intf_mac_address : string;
  intf_speed : int;
  intf_type <json name="type"> : string;
  available : bool;
  default_gw : bool;
  intf_configuration <json name="inft_configuration"> : intf_conf_type;
}

type intf_conf_type = {
  ipv4_address : string;
  ipv4_netmask : string;
  ipv4_gateway : string;
  ipv6_address : string;
  ipv6_netmask : string;
  ?ipv6_gateway : string option;
  ?bus_address : string option;

}

type pos_spec_type = {
  lat : float;
  lon : float;
}

(* NODE STATUS *)

type node_status = {
  uuid : string;
  ram : ram_status;
  disk : disk_status list;
  neighbors : neighbor list;
  (* number_of_fdus: int; *)
  (* Network Statistics *)
}

type ram_status = {
  total : float;
  free : float;
}


type disk_status = {
  mount_point : string;
  total : float;
  free : float;
}

(* NEIGHBOR INFO *)

type neighbor_peer_info = {
  name : string;
  id : string;
}

type neighbor_info = {
  node : neighbor_peer_info;
  port : neighbor_peer_info;
}

type neighbor = {
  src : neighbor_info;
  dst : neighbor_info;
}





(* PLUGINS INFO*)

type plugins_info_type = {
  plugins : plugin list;
}





(* Networks Types *)
type network = {
  uuid : string;
  name : string;
  network_type : string; (* This filed should contain information about the network type/overlay type  *)
  ?status : string option;
  ?virtual_device : string option;
  ?ip_range : string option;
  ?ip_type : string option;
  ?gateway : string option;
  ?dns : string option;
  ?dhcp_range : string option;
  ?interfaces : string list option;
  ?overlay_info : json option;
  ?has_dhcp : bool option;
  ?nodes : string list option;

}


type vxlan_overlay_details = {
  ?vxlan_id : int option;
  ?vxlan_dev : string option;
  ?multicast_address : string option;
}


type atomic_entity_connection_point = {
  connection_point_uuid : string;
  ?addresses : address_info list option;
  ?intf_name : string option;
  ?br_name : string option;
  ?intf_type <json name="type"> : string option;
  ?is_sap : bool option;
  virtual_link: vl_atomic_entity option;
  network_uuid : string option;
}

type address_info = {
  address_info_uuid : string;
  ?mac_address : string option;
  ?ipv4_address : string option;
  ?ipv4_netmask : string option;
  ?ipv4_gateway : string option;
  ?ipv6_address : string option;
  ?ipv6_netmask : string option;
  ?ipv6_gateway : string option;
  ?bus_address : string option;
}

type vl_atomic_entity = {
  vl_uuid : string;
  protocol : string;
  flow_pattern : string;
  description : string;
  vl_qos : vl_qos;
}

type vl_qos = {
  vl_qos_uuid : string;
  bitrate : int;
  latency : int;
  packet_delay_variation : float;
  packet_loss_ratio : int;
  priority : int;
}

(* Atomic Entity Types *)

type vm_atomic_entity = {
  name : string;
  uuid : string;
  ?flavor_id : string option;
  ?vcpus : int option;
  ?memory : int option;
  ?disk_size : int option;
  base_image : string;
  ?user_data <json name="user-data"> : string option;
  ?ssk_keys <json name="ssk-keys">: string list option;
             ?connection_point : atomic_entity_connection_point list option;
            }

type container_atomic_entity = {
  name : string;
  uuid : string;
  base_image : string;
  ?user_data <json name="user-data"> : string option;
  ?ssk_keys <json name="ssk-key">: string list option;
             ?connection_point : atomic_entity_connection_point list option;
            }

type na_atomic_entity = {
  name : string;
  uuid : string;
  command : string;
  ?source : string option;
  ?args : string list option;
}
